转载请注明链接:

# JVM中的垃圾回收

版本号:2018/09/24-1(18:00)

---

[TOC]

---

## 垃圾回收

1、什么是垃圾回收?
> 1. 将已经分配出去，但是不再使用的内存回收起来。以便于再次分配。

2、在JVM中垃圾回收中的垃圾所占的内存空间具体是指什么?
> 死亡对象所占据的堆空间

3、JVM垃圾回收的关键?如何判断一个对象是存活还是死亡的？
> 1. 关键是：如何判断判断一个对象是存活还是死亡的
> 1. 有两个方法判断:
>        1. 引用计数法
>        1. 可达性分析

### 引用计数法

4、引用计数法是什么?
> 1. reference counting
> 1. 一种古老的辨别方法
> 1. 为每个对象添加引用计数器，记录指向该对象的引用的个数
> 1. 引用计数一旦为0，代表该对象已经死亡。

5、引用计数法的实现思路?
> 1. 一个引用指向一个对象，该对象的引用计数+1
> 1. 指向一个对象的引用，赋值为其他值，该对象的引用计数-1

6、引用计数法的缺点?
> 1. 需要为空间来存储计数器
> 1. 繁琐的更新操作：需要截获所有引用更新操作，并且相应加减对象的引用计数器。
> 1. 重要缺陷是无法处理循环引用的对象

7、什么是引用更新操作?
> 1. 将引用指向一个对象，或者赋值为其他值。就是在更新引用。

8、为什么无法处理循环引用的对象？
> 1. a和b之间相互引用，但是没有其他引用指向a和b。a和b实际上已经死了。可是因为计数器的值不为0，导致无法回收。
> 1. 最终导致内存泄漏

### 可达性分析

9、JVM主流的垃圾回收器采用可达性分析算法，可达性分析算法是什么?
> 1. 本质将一系列gc roots作为初始的存活对象集合(live set)
> 1. 会从该集合出发，探索所有能够被引用到的对象，并且将其加入到存活对象集合中。
> 1. 这就是标记过程(mark)，没有被标记的对象，就判定为死亡。


10、垃圾回收中的标记过程是干什么的?
> 1. 会从GC roots出发，探索所有能够被引用到的对象，并且将其加入到存活对象集合中。标记过的对象，就判定为存活。

11、GC roots是什么?
> 一种由堆外指向堆内的引用

12、GC roots有哪些?
> 1. Java方法栈帧中的局部变量
> 1. 已加载类的静态变量
> 1. JNI Handles
> 1. 已启动且未停止的Java线程

13、可达性分析如何解决的循环引用问题？
> 1. 虽然a和b互相引用，直到GC Roots无法达到a和b，就不会将其添加到存活集合中。判定为死亡。

14、可达性分析算法在实践应用中的问题？
> 1. 多线程中的误报和漏报
> 1. xxx

15、可达性分析在多线程中遭遇的误报具体是什么?
> 1. 多线程中，可达性分析时已经访问到了该对象，认为该对象是存活的。然而这之后其他线程将其引用设置为null。
> 1. 会导致错过本次可以回收的机会。因为设置为了null应该回收对象，却被认为是存活的。
> 1. 误报这种情况问题不大，下次垃圾回收时依旧能进行回收。

16、可达性分析在多线程中遭遇的漏报具体是什么?
> 1. 多线程中，可达性分析时访问不到某对象，所以认为该对象是死亡的。与此同时其他线程又持有了该对象的引用。在垃圾回收后，对该对象的访问会导致JVM崩溃！
> 1. 漏报这种情况问题非常严重！

### Stop-The-World

17、如何解决可达性分析算法在多线程中的问题？
> 1. 采用简单粗暴的方式， Stop the worlds(STW)
> 1. 在垃圾回收时，停止其他所有非垃圾回收的线程，直到垃圾回收完成。
> 1. 会造成垃圾回收中所谓的暂停时间-GC pause

18、STW有什么问题?
> 会造成GC pause

19、垃圾回收中的GC pause是什么?

20、JVM中的STW是如何实现的？
> 1. 通过安全点(safe point)来实现
> 1. JVM收到STW请求后，会等到所有线程达到安全点，才会让请求STW的线程开始独占工作

21、安全点是什么？

22、安全点的本质目的是为了让其他线程停下？
> 并不是。
> 1. 安全点是为了让线程找到一个稳定的执行状态
> 1. 在这个状态下，JVM的堆栈不会发生变化。
> 1. JVM会将处于稳定状态的代码作为一个安全点，只要不离开该安全点，JVM就能在垃圾回收时，继续运行这段本地代码。
> 1. 最终保证垃圾回收器能够安全地进行可达性分析。

23、怎样才是一个稳定的执行状态(JVM堆栈不会发生改变)?
> 1. 举个例子，当Java程序通过JNI执行本地代码时，如果这段代码`不访问Java对象`、`不调用Java方法`或者`不返回至原Java方法`
> 1. 那么 Java 虚拟机的堆栈不会发生改变，也就代表着这段本地代 码可以作为同一个安全点。
> 1. 只要不离开这个安全点，Java 虚拟机便能够在垃圾回收的同时，继续运行这段本地代码。

24、Java线程具有哪几种执行状态?(4种)
> 1. 执行JNI本地代码
> 1. 解释执行字节码
> 1. 执行即时编译器生成的机器码
> 1. 线程阻塞

25、执行JNI本地代码如何进入安全点?
> 1. `访问Java对象`、`调用Java方法`或者`返回至原Java方法`这三个操作需要通过 JNI 的 API 来完成
> 1. JVM只需要在API的入口进行安全点检测(safepoint poll)
> 1. 测试是否有其他线程请求停留在安全点里(其他线程请求STW)，便可以在必要的时候挂起当前线程。

26、安全点检测是干什么的?
> 1. 测试是否有其他线程请求停留在安全点里(检测是否有其他线程发送STW请求)
> 1. 安全点检测位于哪些会造成执行状态不稳定的API入口处
> 1. 当其他线程有STW请求，表明不能去执行这些不稳定的API，因此该安全点检测会将线程挂起。
> 1. 当其他线程没有STW请求，因此去执行这些不稳定的API不会造成什么影响。

27、线程阻塞的安全点检测？
> 1. 阻塞的线程由于处于JVM线程调度器的掌控之下，因此属于安全点。
> 1. 不需要安全点检测

28、执行JNI本地代码、解释执行字节码、执行即时编译器生成的机器码这三种运行状态需要虚拟机保证在可预见的时间内进入安全点，不然会怎么样?
> 否则，垃圾回收线程可能长期处于等待所有线程进入安全点的状态，从而变相地提高了垃圾回收的暂停时间。

29、解释执行字节码时，需要如何进入安全点?
> 1. 对于解释执行来说，字节码与字节码之间皆可作为安全点。
> 1. JVM采取的做法是，当有安全点请求时，执行一条字节码便进行一次安全点检测。


30、执行即时编译器生成的机器码，需要如何进行安全点检测?
> 1. 这种情况比较复杂。这些代码直接运行在底层硬件之上，不受 JVM掌控，
> 1. 因此在生成机器码时，即时编译器需要插入安全点检测，以避免机器码长时间没有安全点检测的情况。
> 1. HotSpot 虚拟机的做法是在两处插入安全点检测：
>        1. 生成代码的方法出口处
>        1. 非计数循环的循环回边（back-edge）处

31、非计数循环的循环回边处是什么?

32、为什么不在每一条机器码或者每一个机器码基本块处插入安全点检测呢？
> 原因主要有两个:
> 1. 第一，安全点检测本身也有一定的开销。过多对性能有影响
> 1. 第二，即时编译器生成的机器码打乱了原本栈桢上的对象分布状况。因此会需要额外的信息，而这些信息需要很多空间来存储，即时编译器会尽量避免过多的安全点检测。

33、HotSpot虚拟机如何简化机器码中的安全点检测?
>   1. 已经将机器码中安全点检测简化为一个`内存访问操作`。
>   1. 在有安全点请求的情况下，JVM会将安全点检测访问的内存所在的页设置为不可读
>   1. 并且定义一个 segfault 处理器，来截获因访问该不可读内存而触发segfault的线程，并将它们挂起。

34、HotSpot如何解决即时编译器生成的机器码打乱了原本栈桢上的对象分布状况的这个问题?
> 1. 这个问题影响了安全点检测
> 1. 在进入安全点时，机器码需要提供一些额外的信息来帮助垃圾回收器能够枚举 GC Roots:
>          1. 这些信息能表明哪些寄存器，或者当前栈帧上的哪些内存空间存放着指向对象的引用。
> 1. 但是由于这些信息需要不少空间来存储，因此即时编译器会尽量避免过多的安全点检测。

35、不同的即时编译器插入安全点检测的位置也可能不同?有什么不同？
> 1. Graal 为例，除了生成代码的方法出口处、非计数循环的循环回边（back-edge）处外，还会在`计数循环的循环回边处`插入安全点检测。
> 1. 其他的虚拟机也可能选取方法入口而非方法出口来插入安全点检测。
> 1. 本质目的都是在可接受的性能开销以及内存开销之内，避免机器码长时间不进入安全点的情况，间接地减少垃圾回收的暂停时间。

36、安全点除了垃圾回收外还有哪些场景可以利用该机制？
> 1. JVM其他一些对堆栈内容的一致性有要求的操作时。

## 垃圾回收的三种方法

1、主流的基本回收方式有哪几种(3种)?
> 1. 第一种是清除（sweep）
> 1. 第二种是压缩（compact）
> 1. 第三种则是复制（copy）

当然，现代的垃圾回收器往往会综合上述几种回收方式，综合它们优点的同时规避它们的缺点。 在下一篇中我们会详细介绍 Java 虚拟机中垃圾回收算法的具体实现。

2、清除的基本原理是什么?
> 1. 把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。
> 1. 当需要新建对象时，`内存管理模块`会从该空闲列表中寻找空闲内存，进行分配。
![清除](https://static001.geekbang.org/resource/image/f2/03/f225126be24826658ca5a899fcff5003.png)

3、清除的优缺点?
> 1. 优点是: 这种回收方式的原理及其简单
> 1. 会造成内存碎片。
>      1. JVM的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。
>      1. 比如：空闲内存不足以分配给一个对象，就会导致无法分配。
> 1. 分配效率较低。
>      1. 如果是一块连续的内存空间，可以通过指针加法（pointer bumping）来做分配。
>      1. 而对于空闲列表，JVM则需要逐个访问列表中的项，来查找大小足够的空闲内存。

4、压缩的基本原理?
> 1. 把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。
> 1. 这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。
![压缩](https://static001.geekbang.org/resource/image/41/39/415ee8e4aef12ff076b42e41660dad39.png)

5、压缩的优缺点?
> 1. 优点：能够解决内存碎片化的问题
> 1. 缺点: 压缩算法的性能开销

6、复制的基本原理
> 1. 把内存区域分为两等分，分别用两个指针 from 和 to 来维护
> 1. 并且只是用 from 指针指向的内存区域来分配内存。
> 1. 当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中
> 1. 并且交换 from 指针和 to 指针的内容
![复制的基本原理](https://static001.geekbang.org/resource/image/47/61/4749cad235deb1542d4ca3b232ebf261.png)

7、复制的优缺点?
> 1. 优点: 能够解决内存碎片化的问题
> 1. 缺点: 堆空间的使用效率极其低下

8、复制这种垃圾回收方式，为什么堆空间的使用效率极其低下?




## 问题汇总

## 参考资料
