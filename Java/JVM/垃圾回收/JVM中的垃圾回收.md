转载请注明链接:

# JVM中的垃圾回收

版本号:2018/09/24-1(18:00)

---

[TOC]

---

## 垃圾回收(42)

1、什么是垃圾回收?
> 1. 将已经分配出去，但是不再使用的内存回收起来。以便于再次分配。

2、在JVM中垃圾回收中的垃圾所占的内存空间具体是指什么?
> 死亡对象所占据的堆空间

3、JVM垃圾回收的关键?如何判断一个对象是存活还是死亡的？
> 1. 关键是：如何判断判断一个对象是存活还是死亡的
> 1. 有两个方法判断:
>        1. 引用计数法
>        1. 可达性分析

### 引用计数法

4、引用计数法是什么?
> 1. reference counting
> 1. 一种古老的辨别方法
> 1. 为每个对象添加引用计数器，记录指向该对象的引用的个数
> 1. 引用计数一旦为0，代表该对象已经死亡。

5、引用计数法的实现思路?
> 1. 一个引用指向一个对象，该对象的引用计数+1
> 1. 指向一个对象的引用，赋值为其他值，该对象的引用计数-1

6、引用计数法的缺点?
> 1. 需要为空间来存储计数器
> 1. 繁琐的更新操作：需要截获所有引用更新操作，并且相应加减对象的引用计数器。
> 1. 重要缺陷是无法处理循环引用的对象

7、什么是引用更新操作?
> 1. 将引用指向一个对象，或者赋值为其他值。就是在更新引用。

8、为什么无法处理循环引用的对象？
> 1. a和b之间相互引用，但是没有其他引用指向a和b。a和b实际上已经死了。可是因为计数器的值不为0，导致无法回收。
> 1. 最终导致内存泄漏

### 可达性分析

9、JVM主流的垃圾回收器采用可达性分析算法，可达性分析算法是什么?
> 1. 本质将一系列gc roots作为初始的存活对象集合(live set)
> 1. 会从该集合出发，探索所有能够被引用到的对象，并且将其加入到存活对象集合中。
> 1. 这就是标记过程(mark)，没有被标记的对象，就判定为死亡。


10、垃圾回收中的标记过程是干什么的?
> 1. 会从GC roots出发，探索所有能够被引用到的对象，并且将其加入到存活对象集合中。标记过的对象，就判定为存活。

11、GC roots是什么?
> 一种由堆外指向堆内的引用

12、GC roots有哪些?
> 1. Java方法栈帧中的局部变量
> 1. 已加载类的静态变量
> 1. JNI Handles
> 1. 已启动且未停止的Java线程

13、可达性分析如何解决的循环引用问题？
> 1. 虽然a和b互相引用，直到GC Roots无法达到a和b，就不会将其添加到存活集合中。判定为死亡。

14、可达性分析算法在实践应用中的问题？
> 1. 多线程中的误报和漏报
> 1. xxx

15、可达性分析在多线程中遭遇的误报具体是什么?
> 1. 多线程中，可达性分析时已经访问到了该对象，认为该对象是存活的。然而这之后其他线程将其引用设置为null。
> 1. 会导致错过本次可以回收的机会。因为设置为了null应该回收对象，却被认为是存活的。
> 1. 误报这种情况问题不大，下次垃圾回收时依旧能进行回收。

16、可达性分析在多线程中遭遇的漏报具体是什么?
> 1. 多线程中，可达性分析时访问不到某对象，所以认为该对象是死亡的。与此同时其他线程又持有了该对象的引用。在垃圾回收后，对该对象的访问会导致JVM崩溃！
> 1. 漏报这种情况问题非常严重！

### Stop-The-World

17、如何解决可达性分析算法在多线程中的问题？
> 1. 采用简单粗暴的方式， Stop the worlds(STW)
> 1. 在垃圾回收时，停止其他所有非垃圾回收的线程，直到垃圾回收完成。
> 1. 会造成垃圾回收中所谓的暂停时间-GC pause

18、STW有什么问题?
> 会造成GC pause

19、垃圾回收中的GC pause是什么?
> 垃圾回收中，需要停止所有非垃圾回收线程从而导致了暂停时间

20、JVM中的STW是如何实现的？
> 1. 通过安全点(safe point)来实现
> 1. JVM收到STW请求后，会等到所有线程达到安全点，才会让请求STW的线程开始独占工作

21、安全点是什么？
> 1. 一种机制，保证线程能找到一种稳定的执行状态(也就是JVM堆栈不会发生改变)

22、安全点的本质目的是为了让其他线程停下？
> 并不是。
> 1. 安全点是为了让线程找到一个稳定的执行状态
> 1. 在这个状态下，JVM的堆栈不会发生变化。
> 1. JVM会将处于稳定状态的代码作为一个安全点，只要不离开该安全点，JVM就能在垃圾回收时，继续运行这段本地代码。
> 1. 最终保证垃圾回收器能够安全地进行可达性分析。

23、怎样才是一个稳定的执行状态(JVM堆栈不会发生改变)?
> 1. 举个例子，当Java程序通过JNI执行本地代码时，如果这段代码`不访问Java对象`、`不调用Java方法`或者`不返回至原Java方法`
> 1. 那么 Java 虚拟机的堆栈不会发生改变，也就代表着这段本地代 码可以作为同一个安全点。
> 1. 只要不离开这个安全点，Java 虚拟机便能够在垃圾回收的同时，继续运行这段本地代码。

24、Java线程具有哪几种执行状态?(4种)
> 1. 执行JNI本地代码
> 1. 解释执行字节码
> 1. 执行即时编译器生成的机器码
> 1. 线程阻塞

25、执行JNI本地代码如何进入安全点?
> 1. `访问Java对象`、`调用Java方法`或者`返回至原Java方法`这三个操作需要通过 JNI 的 API 来完成
> 1. JVM只需要在API的入口进行安全点检测(safepoint poll)
> 1. 测试是否有其他线程请求停留在安全点里(其他线程请求STW)，便可以在必要的时候挂起当前线程。

26、安全点检测是干什么的?
> 1. 测试是否有其他线程请求停留在安全点里(检测是否有其他线程发送STW请求)
> 1. 安全点检测位于哪些会造成执行状态不稳定的API入口处
> 1. 当其他线程有STW请求，表明不能去执行这些不稳定的API，因此该安全点检测会将线程挂起。
> 1. 当其他线程没有STW请求，因此去执行这些不稳定的API不会造成什么影响。

27、线程阻塞的安全点检测？
> 1. 阻塞的线程由于处于JVM线程调度器的掌控之下，因此属于安全点。
> 1. 不需要安全点检测

28、执行JNI本地代码、解释执行字节码、执行即时编译器生成的机器码这三种运行状态需要虚拟机保证在可预见的时间内进入安全点，不然会怎么样?
> 否则，垃圾回收线程可能长期处于等待所有线程进入安全点的状态，从而变相地提高了垃圾回收的暂停时间。

29、解释执行字节码时，需要如何进入安全点?
> 1. 对于解释执行来说，字节码与字节码之间皆可作为安全点。
> 1. JVM采取的做法是，当有安全点请求时，执行一条字节码便进行一次安全点检测。


30、执行即时编译器生成的机器码，需要如何进行安全点检测?
> 1. 这种情况比较复杂。这些代码直接运行在底层硬件之上，不受 JVM掌控，
> 1. 因此在生成机器码时，即时编译器需要插入安全点检测，以避免机器码长时间没有安全点检测的情况。
> 1. HotSpot 虚拟机的做法是在两处插入安全点检测：
>        1. 生成代码的方法出口处
>        1. 非计数循环的循环回边（back-edge）处

31、非计数循环的循环回边处是什么?

32、为什么不在每一条机器码或者每一个机器码基本块处插入安全点检测呢？
> 原因主要有两个:
> 1. 第一，安全点检测本身也有一定的开销。过多对性能有影响
> 1. 第二，即时编译器生成的机器码打乱了原本栈桢上的对象分布状况。因此会需要额外的信息，而这些信息需要很多空间来存储，即时编译器会尽量避免过多的安全点检测。

33、HotSpot虚拟机如何简化机器码中的安全点检测?
>   1. 已经将机器码中安全点检测简化为一个`内存访问操作`。
>   1. 在有安全点请求的情况下，JVM会将安全点检测访问的内存所在的页设置为不可读
>   1. 并且定义一个 segfault 处理器，来截获因访问该不可读内存而触发segfault的线程，并将它们挂起。

34、HotSpot如何解决即时编译器生成的机器码打乱了原本栈桢上的对象分布状况的这个问题?
> 1. 这个问题影响了安全点检测
> 1. 在进入安全点时，机器码需要提供一些额外的信息来帮助垃圾回收器能够枚举 GC Roots:
>          1. 这些信息能表明哪些寄存器，或者当前栈帧上的哪些内存空间存放着指向对象的引用。
> 1. 但是由于这些信息需要不少空间来存储，因此即时编译器会尽量避免过多的安全点检测。

35、不同的即时编译器插入安全点检测的位置也可能不同?有什么不同？
> 1. Graal 为例，除了生成代码的方法出口处、非计数循环的循环回边（back-edge）处外，还会在`计数循环的循环回边处`插入安全点检测。
> 1. 其他的虚拟机也可能选取方法入口而非方法出口来插入安全点检测。
> 1. 本质目的都是在可接受的性能开销以及内存开销之内，避免机器码长时间不进入安全点的情况，间接地减少垃圾回收的暂停时间。

36、安全点除了垃圾回收外还有哪些场景可以利用该机制？
> 1. JVM其他一些对堆栈内容的一致性有要求的操作时。


37、STW的机制非常不友好，有哪些解决之道？原理是什么？
> 1. 采用并行GC可以减少需要STW的时间
> 1. 它们会在即时编译器生成的代码中加入`写屏障`或者`读屏障`

38、GC时有时候会突然出现较长的时间消耗，是为什么？
> 1. 这就是长暂停
> 1. 一般Full Gc会造成长暂停

39、Full GC有卡顿，对性能很不利，该如何避免？
> 1. 通过调整新生代大小，使对象在其生命周期内都处于新生代中。
> 1. 这样`Minor GC`就能收集完这些短命对象，而不需要去Full GC

40、多线程为什么会导致误报和漏报？
> 没有引入STW的时候才会出现。现代JVM引入STW后不存在该问题。

### 安全点检测的性能

41、有安全点和无安全点的性能差距有多少?
> 1. 无安全点检测的计数循环带来的长暂停:foo()运行时间为11884ms
> 1. 有安全点检测: bar()运行时间为3628ms
```java
// time java SafepointTestp /
// 你还可以使用如下几个选项
// -XX:+PrintGC
// -XX:+PrintGCApplicationStoppedTime
// -XX:+PrintSafepointStatistics
// -XX:+UseCountedLoopSafepoints

public class SafepointTest {
    static double sum = 0;


    public static void foo() {
        long start = System.currentTimeMillis();
        for (int i = 0; i < 0x77777777; i++) {
            sum += Math.sqrt(i);
        }
        long end = System.currentTimeMillis();
        System.out.println("end - start = " + (end - start));
    }


    public static void bar() {
        long start = System.currentTimeMillis();
        for (int i = 0; i < 50_000_000; i++) {
            new Object().hashCode();
        }
        long end = System.currentTimeMillis();
        System.out.println("end - start = " + (end - start));
    }

    public static void main(String[] args) {
      // 两次测试分别运行一个方法
        new Thread(SafepointTest::foo).start();
        //new Thread(SafepointTest::bar).start();
    }
}
```

42、foo中将int换为long，为什么就没有长暂停了？(具有了安全点)
> C2一个诡异的地方：
```java
for(int i = start; i < limit; i++){
  ...
}
```
> 1. 对于int循环变量i，如果满足下列条件，C2会将其判定为计数循环(counted loop)，默认不插入安全点。
>       1. 该循环变量的循环出口只有一个，i < limit
>       1. 循环变量的增量为常数(i++), 且limit和循环无关。
> 2. 对于long类型循环变量，C2直接识别为非计数循环，需要插入安全点。

## 垃圾回收的三种方法(8)

1、主流的基本回收方式有哪几种(3种)?
> 1. 第一种是清除（sweep）
> 1. 第二种是压缩（compact）
> 1. 第三种则是复制（copy）

2、清除的基本原理是什么?
> 1. 把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。
> 1. 当需要新建对象时，`内存管理模块`会从该空闲列表中寻找空闲内存，进行分配。
![清除](https://static001.geekbang.org/resource/image/f2/03/f225126be24826658ca5a899fcff5003.png)

3、清除的优缺点?
> 1. 优点是: 这种回收方式的原理及其简单
> 1. 会造成内存碎片。
>      1. JVM的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。
>      1. 比如：空闲内存不足以分配给一个对象，就会导致无法分配。
> 1. 分配效率较低。
>      1. 如果是一块连续的内存空间，可以通过指针加法（pointer bumping）来做分配。
>      1. 而对于空闲列表，JVM则需要逐个访问列表中的项，来查找大小足够的空闲内存。

4、压缩的基本原理?
> 1. 把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。
> 1. 这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销。
![压缩](https://static001.geekbang.org/resource/image/41/39/415ee8e4aef12ff076b42e41660dad39.png)

5、压缩的优缺点?
> 1. 优点：能够解决内存碎片化的问题
> 1. 缺点: 压缩算法的性能开销

6、复制的基本原理
> 1. 把内存区域分为两等分，分别用两个指针 from 和 to 来维护
> 1. 并且只是用 from 指针指向的内存区域来分配内存。
> 1. 当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中
> 1. 并且交换 from 指针和 to 指针的内容
![复制的基本原理](https://static001.geekbang.org/resource/image/47/61/4749cad235deb1542d4ca3b232ebf261.png)

7、复制的优缺点?
> 1. 优点: 能够解决内存碎片化的问题
> 1. 缺点: 堆空间的使用效率极其低下

8、复制这种垃圾回收方式，为什么堆空间的使用效率极其低下?

## 对象的生命周期

1、Java对象生命周期的假设
> 1. 大部分Java对象会存活一小段时间
> 1. 小部分Java对象会存活很长一段时间
![Java对象生命周期](https://static001.geekbang.org/resource/image/e2/89/e235d25ca15b60a511a2d90317eb9589.png)

2、JVM的分代回收思想是基于什么假设产生的？
> 基于Java对象生命周期的假设。

3、JVM的分代回收是指什么?
> 将对空间分为两代：
> 1. 新生代
> 1. 老年代

4、新生代是什么？
> 1. 用于存储新建的对象
> 1. 当存活时间足够长时，则移动到老年代。

5、JVM中新生代适合怎样的回收算法？
> 1. 适合频繁采用耗时较短的算法-Minor GC
> 1. 让大部分垃圾在新生代就能被回收

6、JVM中老年代适合采用什么回收算法?
> 1. 回收方式采用全堆扫描

7、JVM老年代出现垃圾回收操作的原因？
> 1. 误判了对象的存活时间(本质应该放置于新生代)
> 1. 堆空间已经耗尽

8、全堆扫描的问题和优化？
> 1. 全堆扫描是一种不计消耗时间的方法，性能低
> 1. 当代JVM也在努力发展并发回收，以减少全堆扫描的情况。

9、JVM的堆如何划分的？新生代分为哪些区域？
> 1. JVM堆划分为新生代和老年代
> 1. 新生代分为：Eden区、两个大小相同的Survivor区
![JVM的堆如何划分的](https://static001.geekbang.org/resource/image/2c/e5/2cc29b8de676d3747416416a3523e4e5.png)

10、JVM采用的动态分配策略是什么？
> 1. 默认情况下，Java 虚拟机采取的是一种动态分配的策略
> 1. 根据`生成对象的速率`和`Survivor区的使用情况`动态调整` Eden 区`和` Survivor 区`的比例。

11、是用什么虚拟机参数可以调整动态分配策略中的比例？
> 1. 对应 Java 虚拟机参数 `XX:+UsePSAdaptiveSurvivorSizePolicy`

12、如果动态分配策略中的比例(Eden/Survivoer)越低，浪费的堆空间将越多?
> 1. 是的
> 1. 两个Survivor区中一个Survivor区会一直为空，如果比率越低，导致Survivor区越高，浪费的堆空间就越多。

13、使用`new`指令时是在哪个区域中申请内存?
> 1. 新生代的Eden区域中划分内存，用于存储对象。

14、new指令申请内存时，为什么是在新生代的Eden区域中划分?而不是在新生代的Survivor区域或者老年代的区域中划分？
> 1. 新生代就是用于存储新建的对象
> 1. 采用Eden区域是JVM规范中规定的。

15、堆空间是线程共享的吗?
> 是

16、new指令在堆空间划分空间需要进行同步吗?
> 需要
> 1. 因为堆空间是线程共享的
> 1. 不然会出现剐蹭事故-两个线程将对象存放到同一个堆空间中

17、JVM如何解决堆空间中划分空间的同步问题？
> 1. JVM解决办法是为每个线程预先申请一片空间，也就是`TLAB技术`(Thread Local Allocation Buffer)
> 1. new指令去申请内存时，直接在该内存空间中划分。


18、TLAB技术是什么?
> 1. 线程局部分配缓存区-Thread Local Allocation Buffer
> 1. 用于解决在堆空间中划分空间的同步问题
> 1. 每个线程可以向JVM申请一段连续的内存，如2048byte，作为线程私有的TLAB
> 1. 该申请操作需要加锁
> 1. 线程需要重点维护两个指针
>       1. 一个指向TLAB中空余内存的起始地址
>       1. 一个指向TLAB的末尾

19、如果TLAB的空间不够用时该怎么办?
> 线程继续向JVM申请更大的空间

20、TLAB技术下，new指令申请内存的流程?
> 1. new指令直接采用`指针加法`(bump the pointer)来实现
> 1. 在指向空余内存的起始位置的基础上，将该指针加上`所请求的字节数`
> 1. 如果加法后空余内存指针的值仍小于或等于指向末尾的指针，则代表分配成功。
> 1. 否则，TLAB已经没有足够的空间来满足本次新建操作。便需要当前线程重新申请新的TLAB。

21、TLAB的虚拟机参数是什么?
> 对应虚拟机参数 `-XX:+UseTLAB`，默认开启

22、当Eden区的空间耗尽了怎么办？
> 1. 每当这个时候 Java 虚拟机便会触发一次 Minor GC，来收集新生代的垃圾。
> 1. 存活下来的对象，则会被送到Survivor区。


前面提到，新生代共有两个 Survivor 区，我们分别用 from 和 to 来指代。其中 to 指向的 Survivior 区是空的。
当发生 Minor GC 时，Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区中，然后交换 from 和 to 指针，以保证下一次 Minor GC 时，to 指向的 Survivor 区还是空的。
Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数 -XX:+MaxTenuringThreshold），那么该对象将被晋升（promote）至 老年代。另外，如果单个 Survivor 区已经被占用了 50%（对应虚拟机参数 XX:TargetSurvivorRatio），那么较高复制次数的对象也会被晋升至老年代。
总而言之，当发生 Minor GC 时，我们应用了标记 - 复制算法，将 Survivor 区中的老存活对象 晋升到老年代，然后将剩下的存活对象和 Eden 区的存活对象复制到另一个 Survivor 区中。理 想情况下，Eden 区中的对象基本都死亡了，那么需要复制的数据将非常少，因此采用这种标记 - 复制算法的效果极好。
Minor GC 的另外一个好处是不用对整个堆进行垃圾回收。但是，它却有一个问题，那就是老年 代的对象可能引用新生代的对象。也就是说，在标记存活对象的时候，我们需要扫描老年代中的 对象。如果该对象拥有对新生代对象的引用，那么这个引用也会被作为 GC Roots。
这样一来，岂不是又做了一次全堆扫描呢？


## 知识扩展

1、Java是快平台的语言，可是又能调用本地方法，而本地方法用C实现，不就破坏了其平台无关性？
> 1. 一般需要C语言实现的代码，都是Java层面无法实现的内容。
> 1. 因此没有办法，只能牺牲平台无关性。

## 问题汇总

## 参考资料
