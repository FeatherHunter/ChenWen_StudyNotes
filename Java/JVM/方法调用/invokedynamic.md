转载请注明链接:

# invokedynamic

版本号:2018/09/15-1(0:00)

---

[TOC]

---

## 赛马问题

1、如何让非马的类能和马一样参加赛马比赛？
```java
    class Horse{
        public void race(){
            System.out.println("马在赛跑");
        }
    }

    class Duck{
        public void race(){
            System.out.println("鸭子在赛跑");
        }
    }

    class Deer{
        public void race(){
            System.out.println("马在赛跑");
        }
    }
```
> 1. 第一种方法：将非马的类型包装成马类进行赛跑。
> 1. 第二种方法：通过反射机制，查找并调用各个类型中的赛跑方法。

2、invokedynamic指令的作用？
> 1. Java7引入的新指令
> 1. 该指令抽象出`调用点`这一个概念
> 1. 允许应用程序将调用点链接至任何符合条件的方法上
> 1. 解决了赛马问题，但是比包装和反射更高效。

## 方法句柄

1、方法句柄是什么？
> 1. MethodHandle-方法句柄
> 1. 是一种更加底层、更加灵活的方法抽象(Java7引入)
> 1. 方法句柄是一个强类型、能够被直接执行的引用。
> 1. 该引用可以指向常规的静态方法、实例方法、构造器、字段。
> 1. 当指向字段时，方法句柄实则指向包含字段访问字节码的`虚构方法`，语义上等价于目标字段的 getter 或者 setter 方法。(但不会直接指向目标字段所在类中的 getter/setter)

2、字节访问字节码的虚构方法是什么？

3、方法句柄的类型是什么？
> 1. MethodType-方法句柄类型
> 1. 方法句柄类型由所指向方法的参数类型、返回类型组成的。
> 1. 是用来 确认方法句柄是否适配的唯一关键。
> 1. 当使用方法句柄时，并不需要关心方法句柄所指向方法的类名或者方法名

4、如果一个兔子的赛跑方法和睡觉方法的参数类型、返回类型一致时？
> 1. 兔子传递的方法句柄，将无法判断是那一个方法。

5、方法句柄的创建？
> 1. 方法句柄的创建是通过 MethodHandles.Lookup 类来完成的。它提供了多个 API，既可以使用 反射 API 中的 Method 来查找，也可以根据类、方法名以及方法句柄类型来查找。
> 1. 当使用后者这种查找方式时，用户需要区分具体的调用类型
> 1. 比如说对于用 invokestatic 调用 的静态方法，我们需要使用 Lookup.findStatic 方法；
> 1. 对于用 invokevirutal 调用的实例方法， 以及用 invokeinterface 调用的接口方法，我们需要使用 findVirtual 方法；
> 1. 对于用 invokespecial 调用的实例方法，我们则需要使用 findSpecial 方法

## 问题汇总

## 参考资料
