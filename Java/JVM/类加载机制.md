转载请注明链接：https://blog.csdn.net/feather_wch/article/details/81672834

介绍JVM类加载机制相关的内容，包括7大阶段，双亲委派模型等内容。

# JVM类加载机制

版本：2018/8/14-1(19:16)

---

[TOC]

1、什么是类加载机制
>1. 虚拟机把描述类的数据从Class文件加载到内存
>1. 并对数据校验、转换解析和初始化
>1. 最终形成可以被虚拟机直接使用的Java类型。

2、Java程序的执行流程
![Java程序的执行流程](http://clubimg.lenovo.com.cn/pic/4223795678672/0)
> 1. java文件(源程序)会被Java编译器进行处理。
> 1. 会生成.class文件(字节码)
> 1. .class文件通过类装载器进行加载。

3、JVM大致的物理结构图
![JVM物理结构图](http://clubimg.lenovo.com.cn/pic/4215659531534/0)

4、Class文件经过类装载器加载后，如何让我们能调用Class对象的功能？
> 1. Class文件经过类装载器加载后，JVM中会生成一份`描述Class结构`的元信息对象。
> 1. 通过元信息对象可以获知Class的结构信息：构造函数，属性，方法等。
> 1. Java允许用户借助元信息对象间接调用Class对象的功能。(就是常见的Class类)

5、类从加载到内存，到从内存中卸载所需要经历的生命周期
![生命周期](http://clubimg.lenovo.com.cn/pic/4215682711324/0)
> 1. 七个阶段：加载、验证、准备、解析、初始化、使用、卸载。
> 1. 验证、准备、解析这三个阶段统称为链接`Linking`

6、类装载器是什么？
> 就是寻找类的字节码文件，并构造类在JVM内部表示的对象组件。

7、装载的作用？
> 查找和导入Class文件

8、链接的作用？
>把类的二进制数据合并到JRE中：
>1. 校验：检查载入的Claa文件数据的证缺陷。
>1. 准备：给类的静态变量分配存储空间。
>1. 解析：将符号引用转成直接引用

9、初始化的作用？
> 对类的静态变量，静态代码块执行初始化操作。

10、Java为何能够动态扩展？
> 1. 能够在`运行时期动态加载`和`动态链接`
> 2. 可以在运行时在指定其实际的实现：多态
> 3. 解析过程有时候还可以在初始化之后执行：动态绑定(多态)

11、什么是动态绑定(多态)
> 1. 例如对象具有两个方法，方法名一致，根据参数是String还是int去判断调用哪个方法。

12、类加载的7哥阶段的顺序。
>1. 加载、验证、准备、初始化、使用、卸载顺序是一致的。
>1. `解析`的顺序并不国定，某些情况下可以再初始化阶段后再开始。
>1. 类的生命周期的每一个阶段通常都是交叉混合进行的，会在一个阶段执行过程中，就激活了另一个阶段。

## 装载(加载)

13、什么是类的加载？
> 1. 将类的class文件中的二进制数据读取到内存中
> 1. 会在`堆区`创建一个java.lang.Class对象。
> 1. 类的加载最终生成的是位于堆区中的Class对象。Class对象封装了类在方法区内的数据结构。
> 1. 该Class对象向程序员提供了访问方法区内的数据结构的接口。

14、类加载的时机？
> 1. 类加载器并不是在某个类被首次主动使用时才加载，会在预料到要被使用时进行预先加载。
> 1. 如果预先加载时，遇到了错误。如果用户之后没有用到该类就不会报错，如果用到了在首次使用时才进行报错。

15、加载.class文件的方式有？(5)
> 1. 从本地系统中直接加载。
> 1. 从网络下载.class文件
> 1. 从zip,jar等文件中加载.class文件
> 1. 从专有数据库中加载.class文件
> 1. 将java源文件动态编译为.class文件(动态代理)

## 验证

16、验证的作用
> 1. 确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求
> 1. 并且不会危害虚拟机自身的安全。

## 准备
17、准备阶段的作用
> 1-为类的静态变量分配内存，并且设置类静态变量的初始值。
```java
public static int v = 8080;
```
> 2-仅仅是`static int v`在准备阶段只会将初始值设置为`0`，而进行`8080赋值`的`putstatic`指令是在程序被编译后，存放于类构造器<client>方法之中。
```java
public static final int v = 8080;
```
> 3-`static final int v`会在编译阶段给V生成ConstantValue属性，并且在准备阶段根据ConstantValue属性`赋值为8080`

## 解析

18、解析的作用
>1. 虚拟机将常量池中的符号引用替换为直接引用的过程。

19、符号引用
>1. 当一个类被加载时，该类所用到的别的类的符号引用都会保存在常量池中。
>1. 一个类中引用了其他类，可是JVM并不知道引入的其他类在哪里，就用符号引用来代替。
>1. 符号应用的目标不一定已经在内存中。
```java
//例如下列常量
CONSTANT_Class_info
CONSTANT_Field_info
CONSTANT_Method_info
```

20、直接引用
>1. 直接引用就是直接指向目标的指针。
>1. 在类加载器解析的时候，会通过符号引用去找到那个引用的类的地址，这个类的地址就是`直接引用`
>1. 引用的目标必定已经存在在内存中。

21、不同内容的解析流程
>1. 类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。
>1. 字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。
>1. 类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。
>1. 接口方法解析：与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了。

## 初始化

22、初始化阶段的作用？
> 1. 是类加载阶段的最后一个阶段。(前面的阶段，只有加载阶段可以自定义类加载器，其他阶段都是由JVM主导)
> 1. 初始化阶段，才真正执行类中定义的Java程序代码。
> 1. 初始化阶段是执行`类构造器Client`方法的过程。
> 1. Client方法是由编译器自动收集类中的静态变量的赋值操作和静态代码块中的语句合并而成的。
> 1. 虚拟机会保证client方法执行前，弗雷德client方法已经执行完毕。
> 1. 如果一个类中没有静态变量赋值也没有静态代码块，则编译器不会给该类生成client方法

23、哪些场景下不到执行类的初始化阶段？
> 1. 通过子类引用父类的静态字段：只会触发父类的初始化，而不会触发子类的初始化。
> 1. 定义对象数组，不会触发该类的初始化。
> 1. 常量在编译时期会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量的类的初始化。
> 1. 通过类名获取Class对象，不会触发类的初始化。
> 1. 通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。
> 1. 通过ClassLoader默认的loadClass方法，也不会触发初始化动作。

## 类加载器
24、JVM提供的类加载器
>加载动作被放到了JVM外部实现，以便让app决定如何获取所需的类。
>1. 启动类加载器(Bootstrap ClassLoader)：负责加载 `JAVA_HOME\lib` 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。
>1. 扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。
>1. 应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库。
![类加载器](http://incdn1.b0.upaiyun.com/2017/06/d330251551f6de988239494ce2773095.png)


25、双亲委派模型是什么？
>1. JVM提供了三种类加载器，还有用户自定义的类加载器。这些加载器之间的层次关系被称为`类加载器的双亲委派模型。`
>1. 该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过`组合（Composition）关系`来实现，而不是通过继承（Inheritance）。

26、双亲委派模型的处理流程
> 1. 某个类加载器在接收到`加载类的请求`时，首先将加载任务委托给父类加载器，依次递归。
> 1. 如果父类加载器可以完成类加载任务，就成功返回
> 1. 只有父类加载器无法完成此加载任务时，才自己去加载。

27、双亲委派模型的优点？
>1. Java类随着它的类加载器一起具备了一种带有优先级的层次关系。
>1. 例如rt.jar中的类java.lang.Object，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在任何情况下都是同一个类。
>1. 反例：如果没有双亲委派模型，而是各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。

28、ClassLoder的loadClass源码解析：
```java
protected Class<?> loadClass(String className, boolean resolve) throws ClassNotFoundException {
    // 1、判断该类是否加载过
    Class<?> clazz = findLoadedClass(className);
    // 2、没有加载过，进行加载。
    if (clazz == null) {
        ClassNotFoundException suppressed = null;
        // 3、交给父类加载器进行加载
        try {
            clazz = parent.loadClass(className, false);
        } catch (ClassNotFoundException e) {
            suppressed = e;
        }
        // 4、父类加载器无法加载，则自身进行加载。
        if (clazz == null) {
            try {
                clazz = findClass(className);
            } catch (ClassNotFoundException e) {
                e.addSuppressed(suppressed);
                throw e;
            }
        }
    }

    return clazz;
}
```

29、ClassLoder的findClass源码解析：
```java
protected Class<?> findClass(String className) throws ClassNotFoundException {
    throw new ClassNotFoundException(className);
}
```
> 是一个空实现，因此留给开发者去实现自己的类加载器。

## 参考资料
1. [简述类加载机制](https://blog.csdn.net/qq_21586317/article/details/80976440)
1. [深入理解类加载机制](https://blog.csdn.net/fgets/article/details/52934178)
1. [JVM 类加载机制详解](http://www.importnew.com/25295.html)
1. [【深入理解JVM】：类加载器与双亲委派模型](https://blog.csdn.net/u011080472/article/details/51332866)
