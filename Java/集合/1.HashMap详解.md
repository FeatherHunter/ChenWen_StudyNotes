
# HashMap
2018/8/2-1(2:14)
---
[TOC]

1、HashMap是什么？
> 1. Map族中最常用的集合
> 2. 是Java Collection Framework的重要成员
> 3. Map是键值对映射的抽象接口，该映射只允许一个键对应一个值
> 4. HashMap存储的对象是Entry(同时包含Key-Value)
> 5. HashMap中会根据hash算法来计算key-value的存储位置并进行快速存取
> 6. HashMap只允许一条Entry的Key为Null(多条会覆盖)，但允许多条Entry的Value为Null
> 7. HashMap是Map的非同步实现。

2、集合存储的是Java对象？
>不是：
> 1. 没有将Java对象放入到容器中
> 2. 容器仅仅保存这些对象的引用，这些引用指向了实际内存地址中的Java对象。

## HashMap原理分析

3、HashMap的实现
> 1. 继承`AbstractMap<K, V>类`: 提供了Map接口的骨干实现，以最大程度减少实现Map接口所需要的工作。
> 2. 实现`Map<K,V>接口`
> 3. 实现`Cloneable接口`：支持浅复制
> 4. 实现`Serializable接口`：支持序列化

### 构造函数

4、HashMap具有的构造方法一共有4种？
> 1. HashMap(): 初始容量-16；负载因子-0.75
> 2. HashMap(int initialCapacity, float loadFactor): 指定初始容量和负载因子
> 3. HashMap(int initialCapacity): 指定初始容量；负载因子-0.75
> 4. HashMap(Map<? extends K, ? extends V> m): 构造与指定Map具有相同映射的HashMap；初始容量>=16；负载因子-0.75

5、HashMap底层数据存储的实现方法是什么？
> 1. 采用`数组`实现，名为table
> 2. 数组的每一项都是`一条链表`

6、初始容量是什么？
> 1. `哈希表`中桶的数量，也就是table数组的大小

7、负载因子是什么？
> 1. 哈希表在其容量自动扩容前可以达到当前总容量的比例(如：达到`当前容量 * 负载因子`时会进行自动扩容)
> 1. 用于衡量的是一个散列表的空间的使用程度
> 1. `负载因子越大`，散列表的装填程度越高

8、负载因子在拉链法的哈希表中的意义？
>1. 使用 `拉链法`的哈希表来说，查找一个元素的平均时间是 `O(1+a)`，a 指的是链的长度，是一个常数。
> 2. 负载因子越大，空间利用越充分，查找效率会越低
> 3. 负载因子越小，数据越稀疏，空间浪费越严重。
> 4. 0.75是系统默认在时间和空间上的折中办法，一般不需要修改。

### 数据结构
9、什么是Hash(哈希)？
> 1. Hash就是把任意长度的输入，通过哈希算法，变换成固定长度的输出(一般是整型值)，该输出就是哈希值。
> 2. 这种转换是一种`压缩映射`，散列值的控件通常远小于输入的空间。
> 3. 不同的输入可能会散列成相同的输出，从而不可能从散列值来唯一的确定输入值。
> 4. 简而言之，就是一种将任意长度的信息压缩到某一个固定长度的消息摘要函数。

10、哈希表的由来？
> 1. 数组的特点：寻址容易，插入和删除困难
> 2. 链表的特点：寻址困难，插入和删除容易
> 3. 哈希表的特点：寻址容易，插入和删除也容易。适合快速查找、插入、删除
> 4. 哈希表有多种实现方法：最经典的是拉链法。

11、拉链法是什么？
> 1. 可以理解为`链表的数组`
> 2. 会根据元素的特征将其分配到不同的链表中
> 3. 通过`元素的特征`去计算`元素数组下标`的方法就是`哈希算法`
![拉链法](http://static.zybuluo.com/Rico123/cb85d6xr1t8976xtqmrzyghv/%E6%8B%89%E9%93%BE%E5%93%88%E5%B8%8C%E8%A1%A8.jpg)

12、使用哈希表的两个关键点
>1. 哈希算法(Hash函数)的选择：应该针对不同的对象(字符串、整数等)采用具体不同的哈希方法。
> 2. hash冲突的处理：一种是开放散列（open hashing）/ 拉链法（针对桶链结构）；另一种是封闭散列（closed hashing）/ 开放定址法。

#### 哈希算法

13、==的作用
> 1. 基本数据类型，比较值是否相等
> 2. 引用类型，比较内存地址是否相等。

14、equals方法的作用
> 1. 本意：比较两个对象的内容是否相等
> 2. Object中equals仅仅是比较两者的引用是否相等。

15、String的equals为什么能正确比较？内部的实现方法？
>重写了`equals`方法：
> 1. 先 比较引用是否相同(是否为同一对象\同一个内存地址)
> 2. 再 判断类型是否一致（是否为同一类型(String)）
> 3. 最后 比较内容是否一致

16、重写equals必须遵守的规则？(5)
> 对称性、自反性、类推性、一致性、对称性

17、hashCode是什么？
> 1. Object类的一个`native方法`
> 2. 会针对不同的对象返回不同的整数(通过将该对象的内部地址转换成一个整数来实现)
> 3. HashCode只是在需要用到哈希算法的数据结构中才有用，比如 HashSet, HashMap 和 Hashtable。
> 4. 本质是系统用来快速检索对象而使用。

18、Java的集合(Collections)有哪几类？(3)
> 1. List: 元素有序；元素可以重复
> 2. Queue: 元素有序；元素可以重复
> 3. Set：元素无序；元素不可以重复
> * Map不属于`Collections`

19、如何保证元素不重复-equals方法？
> 1. 元素重复问题可以通过`Object.equals`判断
> 2. `equals的缺点`在于如果有1000个元素，第1001个元素加入集合时，为了保证不重复，需要调用1000次equals方法。性能低下

20、hashCode方法如何保证元素不重复？
> 1. 通过`hashCode`计算出钙元素对应的值，根据该值计算出元素在数组中的位置。
> 2. 如果该位置上没有数据，将该元素存储到该位置。
> 3. 如果该位置上有数据，调用equals方法将两者比较。
> 4. 元素相同，不进行存储。
> 5. 元素不同，存储到该位置对应的链表中(HashSet, HashMap 和 Hashtable的实现总将元素放到链表的表头)

#### Entry

21、Entry是什么？
> 1. Entry是HashMap的内部类
> 2. 实现了`Map.Entry`接口
> 3. 包含了`key、value、下个节点next、hash值`四个属性
> 4. 是构成哈希表的基石，是哈希表所存储元素的具体形式。

## HashSet
1、 HashMap和HashSet的相似与区别
|HashMap|	HashSet|
|---|---|
| Java Collection Framework重要成员  |Java Collection Framework重要成员   |
| 实现了Map接口|	实现Set接口|
| 存储键值对|	仅存储对象|
| 调用put（）向map中添加元素|	调用add（）方法向Set中添加元素|
| HashMap使用键（Key）计算Hashcode	|HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同(因此使用前要确保重写hashCode（）方法和equals（）方法)|
| HashMap较快，因为它是使用唯一的键获取对象|	HashSet较慢|
| 非线程安全|非线程安全|
| 底层Hash存储机制相同   |底层Hash存储机制相同   |

## LinkedHashMap

40、LinkedHashMap是什么？
> 1. HashMap的直接子类
> 2. 继承所有HashMap的特性
> 3. 额外维护一个双向链表，保持了有序性

## 参考资料
1. [Map 综述一: 彻头彻尾理解 HashMap](https://blog.csdn.net/justloveyou_/article/details/62893086)
2. [Java 中的 ==、equals、hashCode 的区别与联系](https://blog.csdn.net/justloveyou_/article/details/52464440)
3. [解决hash冲突的三个方法](https://www.cnblogs.com/wuchaodzxx/p/7396599.html#H1_4)
