1、事件绑定
> 1.分类：传统事件绑定(内联模型，脚本模型)和现代事件绑定(DOM2级模型)；

2、传统事件绑定的问题
> 1.一个事件处理函数触发两次事件
> 1. 有两个或多个事件处理函数，第一个处理函数就会被第二个覆盖掉；
```
window.onload = function () {
    alert('1');
};
window.onload = function () {
    alert('2');                 //只会打印出2
};
```
> 2. 解决办法：判断是否有这个处理函数；
```
window.onload = function () {
    alert('1');
};
if(typeof window.onload==='function'){   //判断这个事件是否存在
  var saved = null;
  saved = window.onload;                 //定义一个变量保存第一个事件
}
window.onload = function () {
    if(saved)saved();                   //执行第一个事件，相当于window.onload=function(){}
    alert('2');                         //执行本事件
};
```
> 2.事件切换器
> 1. 有两个或多个事件处理函数，第一个处理函数就会被第二个覆盖掉；
```
window.onload = function () {
    var event = document.getElementById('event');
    event.onclick = function () {
        alert('onclick');
    };
    event.onclick = function () {
        alert('onclick2');                //只会输出'onclick2'，将第一个事件覆盖了
    };
};
```
> 2. 将两个处理函数合并到一个函数中，会导致第一个只能执行一次；
```
//解决办法：合并到一起，但仍然存在问题
window.onload = function () {
    var event = document.getElementById('event');
    event.onclick = function(){
        alert('onclick');              //只能执行一次，第二次执行又被覆盖了
        toRed.call(this);              //通过匿名函数执行，该函数里的this表示window对象，可以通过call方法来扩展作用域
    };
};

function toRed() {
    this.className = 'red';    
    this.onclick = toBlue;           //这里的onclick事件把alert给覆盖了
}
function toBlue() {
    this.className = 'blue';    
    this.onclick = toRed;
}
```
> 3. 解决了第一个事件只能执行一次的问题
```
//完整的事件切换器（解决了第一个事件只能执行一次的问题）
/*obj相当于window
type相当于onload
fn相当于匿名函数*/
function addEvent(obj, type, fn) {
    var saved = null;          //保存上一个事件
    if (typeof obj['on' + type] == 'function') {
        saved = obj['on' + type];     //保存上一个事件
    }
    obj['on' + type] = function () {
        if (saved) saved();
        fn.call(this);          //把this传递过去
    };
}
function toRed() {
    this.className = 'red';     //直接引用toRed(不加括号)；this表示event
    addEvent(this,'click',toBlue);
}

function toBlue() {
    this.className = 'blue';    //直接引用toBlue(不加括号)；this表示event
    addEvent(this,'click',toRed);
}

addEvent(window,'load',function(){
    var event = document.getElementById('event');
    addEvent(event,'click',toBlue);
});
```
> 4. 当不停的切换的时候，浏览器突然卡死，并且报错，`Maximum call stack size exceeded`，栈溢出，原因是进行了递归运算，保存了很多事件；
> **解决方法：用完的事件，就立刻移除掉**
```
//删除事件处理函数，这里会把所有的符合的事件都删除了（一刀切）
function removeEvent(obj, type) {
    if (obj['on' + type]) {
        obj['om' + type] = null;
    }
}
```
