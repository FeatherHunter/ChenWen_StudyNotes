转载请注明链接:https://blog.csdn.net/feather_wch/article/details/87910364

# Android 热修复原理

版本号:2019/2/25-0:46

---

[toc]

---

## 技术介绍

### 热修复基本概念

1、传统BUG修复流程的弊端?
> 1. 重新发布版本代价太大
> 2. 用户下载安装成本太高
> 1. BUG修复不及时，用户体验差。

2、对于这些弊端，有哪些合适的解决办法?(or 有哪些方案能够进行BUG的快速修复？)
|方案|内容|缺点|
|---|---|---|
|Hybird方案   |将需要经常变更的业务逻辑通过H5进行独立   |1. 有学习成本，需要对原有逻辑进行合理的抽象和转换。 2. 对于无法转为H5的代码依旧无法修复   |
|插件化方案   |例如`Atlas`以及`DroidPlugin`方案   |1.移植成本高 2.需要学习插件化工具 3. 改造老代码的功能量大|
|热修复   |APP直接从云端下拉补丁和更新   |   |

#### 三大优势

3、热修复的3大优势
> 1. 无需重新发版，实时高效热修复。
> 1. 用户无感知修复，无需下载新的应用，代价小。
> 1. 修复成功率高

#### 三大领域

4、Android 热修复的3大领域
> 1. 代码修复
> 1. 资源修复
> 1. so修复

#### 传统框架实现方式

5、传统热修复框架的实现方式
|框架|方案|缺点|
|---|---|---|
|Xposed   |手淘，`底层结构替换方案`，针对Dalvik虚拟机开发的Java Method Hook技术-Dexposed   |1.对于底层Dalvik结构过于依赖   2.无法继续兼容ART虚拟机(Android 5.0起)|
|Andfix   |支付宝，`底层结构替换方案`，做到了Dalvik和ART环境的全版本兼容。   |   |
|Hotfix   |阿里百川，Andfix升级版，业务逻辑解耦   |1.`底层结构的替换方案``稳定性差`  2.使用范围限制多 3.不支持资源和so修复|
|超级补丁技术   |QQ控件   |   |
|Tinker   |微信，   |   |
|Amigo   |饿了么，   |   |
|Robust   |美团，   |   |


#### Sophix概览

6、Sophix的设计理念
> 1. 核心理念：非侵入性
> 1. 打包过程不会侵入到apk的build流程中。也不会增加任何AOP代码，对开发者透明化。

##### 优势

7、Sophix框架的优势
> 1. 支持代码修复、资源修复、so修复
> 1. 集成非常简单，没有侵入性。


##### 缺点

8、Sophix的缺点
> 1. 唯一缺点，是不支持四大组件的增加。但是支持四大组件的增加必然导致代码侵入性过强。
> 1. 一般热修复也使用于修复故障。而不是增加很多新功能。因此也不需要。
> 1. 可以通过增加Fragment，增加新功能。


### 代码修复

9、代码修复的两大主要方案
> 1. 阿里系的`底层替换方案`。
> 1. 腾讯系的`类加载方案`。

10、底层替换方案和类加载方案的优劣
|方案|优点|缺点|
|---|---|---|
|底层替换   |1.时效性最好 2.加载轻快 3.立即见效   |限制很多   |
|类加载   |1.修复范围广 2.限制少   |1.时效性差，需要冷启动才能见效   |

#### 底层替换方案

##### 传统方案

11、底层替换方案是什么?
> 1. 在已经加载了的类中直接替换掉原有的方法
> 1. 是在原有类的基础上进行的修改，因此无法进行`方法`和`字段`的增减(这会破坏原有类的结构)
> 1. 该方案的底层替换具有`不稳定性`

###### 类方法的增减

12、为什么底层替换方案无法增减原有类的方法？
> 1. 会导致`该类`和`整个Dex`的`方法数`变化
> 1. `方法数的变化`会造成`方法索引的变化`，这样访问方法时，就无法正常所引导正确的方法。

###### 类字段的增减

13、为什么底层替换方案无法增减原有类的字段？
> 1. 增加和减少了`字段`和增减方法一样，会导致`所有字段`的索引发生变化。
> 1. `最严重的是`, 在app运行时某个类突然增加了字段，而原先已经产生的该类的实例还是`原来的结构`(这是无法改变的)，后续对这个老实例对象访问`新增字段`是很致命的。


###### 不稳定性

14、底层替代方案是如何实现的？
> 1. 无论是`Dexposed`、`AndFix`以及其他的`Hook方案`都是直接修改虚拟机方法的具体字段。
> 1. 例如修改`Dalvik`方法的`jni函数指针`、修改类的访问权限、修改方法的访问权限

15、底层替代方案的不稳定性?
> 1.这种依赖于具体字段的Hook方案，各个厂商会对源代码进行改造，从而导致不匹配。
> 1. 例如`Andfix`里`ArtMethod的结构`是根据开源Android源码中的结构写死的。如果结构发生改变，就会导致`替换机制`出错。

##### 无视底层结构的替换方案

16、无视底层具体结构的替换方法
> 1. 忽略底层`ArtMethod`结构的差异
> 1. 所有Android版本都不需要区分
> 即使Android版本不断修改ArtMethod的成员，只要保证ArtMethod数据仍然是`线性结构排序`就没问题

#### 类加载方案

##### 传统方案的原理

17、传统类加载方案原理是什么?
> 1. app重新启动后让`ClassLoader`去加载新的类
> 1. 不重启app，原来的类还在虚拟机中，就无法加载新的类。

18、腾讯系三类加载方案的实现原理
> 1. QQ控件会侵入打包流程，增加无用信息，不优雅。
> 1. QFix方案，获取底层虚拟机的函数，不够稳定可靠，且无法新增public函数
> 1. 微信Tinker，完整的`全量Dex加载`。会对Dex内容非常精细的比较(方法和指令的维度)，性能消耗严重。

##### Dex比较维度

19、Dex的比较维度有三种
> 1. 方法和指令的维度: 粒度过细，性能差
> 1. bsbiff: 粒度粗糙
> 1. 类的维度: 粒度最合适，能够达到`时间和空间平衡`的最佳效果

##### Sophix的方案

20、Sophix的类加载方案
> 1. dex的比较维度：类的维度
> 1. 采用全量合成dex:
>     1. 利用Android原先的类查找和合成机制，快速合成新的全量Dex-不需要处理合成时方法数超过的问题，也不会破坏性重构dex的结构。
>     1. 重新排列包中dex的顺序。虚拟机查找时优先找到classes.dex中的类，然后才是 classes2.dex、classes3.dex

###### 类插桩


21、Sophix中的dex文件级别的类插桩方案
> 1. 将`旧包`和`补丁包`中的classes.dex的顺序进行了重排
> 1. 让系统自动实现类覆盖的目的，大大减少合成补丁的开销

#### 双剑合璧

22、两个方案的合并
> 1. 底层替换方案和类加载方案合并使用
> 1. 补丁工具根据实际代码变动情况：
>         1. 小修改，在底层替代方案的适用范围内：`底层替代方案`-即时生效
>         1. 其余：`类加载方案`-即时性差
> 1. Sophix底层会判断机型是否支持热修复：如果机型底层虚拟机构造不支持，依旧走`类加载修复`

### 资源修复

23、热修复的方案大部分都参考了`Instant Run`的实现

#### Instant Run

24、Instant Run中的资源热修复的原理？
> 1. 构造一个新的`AssetManager`.
> 2. 反射调用`addAssetPath`，将这个完整的新资源包加入到`新AssetManager`中。
> 3. 找到所有引用`旧AssetManager`的地方，通过反射，将引用处替换为`新AssetManager`-该Manager包含所有新资源

25、Instant Run的资源热修复主要工作都是在处理`兼容性`和查找到AssetManager引用处，替换逻辑很简单。

#### Sophix方案

26、Sophix的资源修复方案
> 1. 构造一个`package id = 0x66`的资源包，包含两种资源：1.新增资源 2.原有内容发生改变的资源
> 1. 直接在原有AssetManager中addAssetPath`0x66资源包`，不和已经加载的0x7f冲突
> 1. 直接在原有的AssetManager对象上进行析构和重构。不再需要去找到所有`引用AssetManager的地方`

27、Sophix资源修复方案的优势
> 1. 不修改AssetManager的引用处，替换更快更安全(对比Instant Run以及所有copycat的实现)
> 1. 不必下发完整包，补丁包只包含改动的资源(对比Instant Run、Amigo等方式的实现)
> 1. 不需要在运行时合成完整包。不占用运行时资源。(对比Tinker的实现)

##### 不修改AssetManager的引用处

28、不修改AssetManager的引用处
> 直接在原有的AssetManager对象上进行析构和重构。不再需要去替换所有`旧AssetManager的引用`

##### 不必下发完整包

29、不必下发完整包
> 1. 构造一个`package id = 0x66`的资源包，包含`新增资源`和`原有内容发生改变的资源`
> 1. 直接在原有AssetManager中addAssetPath`0x66资源包`，会优先找到0x66资源包中的资源

##### 不需要在运行时合成完整包

30、不需要在运行时合成完整包
> 1. 采用dex文件级别的类插桩方案
> 1. 重新排列包中dex的顺序。虚拟机查找时优先找到classes.dex中的类，然后才是 classes2.dex、classes3.dex。系统自动实现类覆盖。


### SO库修复

31、SO库修复的原理
> 1. 本质是对native方法的修复和替换
> 1. 采用类似`类修复的反射注入方式`，把`补丁so库`的路径插入到`nativeLibraryDirectories数组`的最前方，这样加载so库的时候是补丁so库
> 1. 该方案在启动期间，反射注入补丁so库，而不是其他方案手动替换系统的`System.load()`来实现替换目的

## 代码热修复

### 底层热替换原理

#### Andfix即时生效的原理

1、Andfix的即时生效原理
> 1. Andfix即时生效，不需要重新启动，但是也有使用限制。
> 1. 方法：在已经加载的类中，直接在navtive层替换掉原方法，

## 问题汇总

## 参考资料
