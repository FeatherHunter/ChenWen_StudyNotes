转载请注明链接:https://blog.csdn.net/feather_wch/article/details/87910364

# Android 热修复原理

版本号:2019/2/28-1:21

---

[toc]
## 技术介绍

### 热修复基本概念

1、传统BUG修复流程的弊端?
> 1. 重新发布版本代价太大
> 2. 用户下载安装成本太高
> 1. BUG修复不及时，用户体验差。

2、对于这些弊端，有哪些合适的解决办法?(or 有哪些方案能够进行BUG的快速修复？)
|方案|内容|缺点|
|---|---|---|
|Hybird方案   |将需要经常变更的业务逻辑通过H5进行独立   |1. 有学习成本，需要对原有逻辑进行合理的抽象和转换。 2. 对于无法转为H5的代码依旧无法修复   |
|插件化方案   |例如`Atlas`以及`DroidPlugin`方案   |1.移植成本高 2.需要学习插件化工具 3. 改造老代码的功能量大|
|热修复   |APP直接从云端下拉补丁和更新   |   |

#### 三大优势

3、热修复的3大优势
> 1. 无需重新发版，实时高效热修复。
> 1. 用户无感知修复，无需下载新的应用，代价小。
> 1. 修复成功率高

#### 三大领域

4、Android 热修复的3大领域
> 1. 代码修复
> 1. 资源修复
> 1. so修复

#### 传统框架实现方式

5、传统热修复框架的实现方式
|框架|方案|缺点|
|---|---|---|
|Xposed   |手淘，`底层结构替换方案`，针对Dalvik虚拟机开发的Java Method Hook技术-Dexposed   |1.对于底层Dalvik结构过于依赖   2.无法继续兼容ART虚拟机(Android 5.0起)|
|Andfix   |支付宝，`底层结构替换方案`，做到了Dalvik和ART环境的全版本兼容。   |   |
|Hotfix   |阿里百川，Andfix升级版，业务逻辑解耦   |1.`底层结构的替换方案``稳定性差`  2.使用范围限制多 3.不支持资源和so修复|
|超级补丁技术   |QQ控件   |   |
|Tinker   |微信，   |   |
|Amigo   |饿了么，   |   |
|Robust   |美团，   |   |


#### Sophix概览

6、Sophix的设计理念
> 1. 核心理念：非侵入性
> 1. 打包过程不会侵入到apk的build流程中。也不会增加任何AOP代码，对开发者透明化。

##### 优势

7、Sophix框架的优势
> 1. 支持代码修复、资源修复、so修复
> 1. 集成非常简单，没有侵入性。


##### 缺点

8、Sophix的缺点
> 1. 唯一缺点，是不支持四大组件的增加。但是支持四大组件的增加必然导致代码侵入性过强。
> 1. 一般热修复也使用于修复故障。而不是增加很多新功能。因此也不需要。
> 1. 可以通过增加Fragment，增加新功能。


### 代码修复

9、代码修复的两大主要方案
> 1. 阿里系的`底层替换方案`。
> 1. 腾讯系的`类加载方案`。

10、底层替换方案和类加载方案的优劣
|方案|优点|缺点|
|---|---|---|
|底层替换   |1.时效性最好 2.加载轻快 3.立即见效   |限制很多   |
|类加载   |1.修复范围广 2.限制少   |1.时效性差，需要冷启动才能见效   |

#### 底层替换方案

##### 传统方案

11、底层替换方案是什么?
> 1. 在已经加载了的类中直接替换掉原有的方法
> 1. 是在原有类的基础上进行的修改，因此无法进行`方法`和`字段`的增减(这会破坏原有类的结构)
> 1. 该方案的底层替换具有`不稳定性`

###### 类方法的增减

12、为什么底层替换方案无法增减原有类的方法？
> 1. 会导致`该类`和`整个Dex`的`方法数`变化
> 1. `方法数的变化`会造成`方法索引的变化`，这样访问方法时，就无法正常所引导正确的方法。

###### 类字段的增减

13、为什么底层替换方案无法增减原有类的字段？
> 1. 增加和减少了`字段`和增减方法一样，会导致`所有字段`的索引发生变化。
> 1. `最严重的是`, 在app运行时某个类突然增加了字段，而原先已经产生的该类的实例还是`原来的结构`(这是无法改变的)，后续对这个老实例对象访问`新增字段`是很致命的。


###### 不稳定性

14、底层替代方案是如何实现的？
> 1. 无论是`Dexposed`、`AndFix`以及其他的`Hook方案`都是直接修改虚拟机方法的具体字段。
> 1. 例如修改`Dalvik`方法的`jni函数指针`、修改类的访问权限、修改方法的访问权限

15、底层替代方案的不稳定性?
> 1.这种依赖于具体字段的Hook方案，各个厂商会对源代码进行改造，从而导致不匹配。
> 1. 例如`Andfix`里`ArtMethod的结构`是根据开源Android源码中的结构写死的。如果结构发生改变，就会导致`替换机制`出错。

##### 无视底层结构的替换方案

16、无视底层具体结构的替换方法
> 1. 忽略底层`ArtMethod`结构的差异
> 1. 所有Android版本都不需要区分
> 即使Android版本不断修改ArtMethod的成员，只要保证ArtMethod数据仍然是`线性结构排序`就没问题

#### 类加载方案

##### 传统方案的原理

17、传统类加载方案原理是什么?
> 1. app重新启动后让`ClassLoader`去加载新的类
> 1. 不重启app，原来的类还在虚拟机中，就无法加载新的类。

18、腾讯系三类加载方案的实现原理
> 1. QQ控件会侵入打包流程，增加无用信息，不优雅。
> 1. QFix方案，获取底层虚拟机的函数，不够稳定可靠，且无法新增public函数
> 1. 微信Tinker，完整的`全量Dex加载`。会对Dex内容非常精细的比较(方法和指令的维度)，性能消耗严重。

##### Dex比较维度

19、Dex的比较维度有三种
> 1. 方法和指令的维度: 粒度过细，性能差
> 1. bsbiff: 粒度粗糙
> 1. 类的维度: 粒度最合适，能够达到`时间和空间平衡`的最佳效果

##### Sophix的方案

20、Sophix的类加载方案
> 1. dex的比较维度：类的维度
> 1. 采用全量合成dex:
>     1. 利用Android原先的类查找和合成机制，快速合成新的全量Dex-不需要处理合成时方法数超过的问题，也不会破坏性重构dex的结构。
>     1. 重新排列包中dex的顺序。虚拟机查找时优先找到classes.dex中的类，然后才是 classes2.dex、classes3.dex

###### 类插桩


21、Sophix中的dex文件级别的类插桩方案
> 1. 将`旧包`和`补丁包`中的classes.dex的顺序进行了重排
> 1. 让系统自动实现类覆盖的目的，大大减少合成补丁的开销

#### 双剑合璧

22、两个方案的合并
> 1. 底层替换方案和类加载方案合并使用
> 1. 补丁工具根据实际代码变动情况：
>         1. 小修改，在底层替代方案的适用范围内：`底层替代方案`-即时生效
>         1. 其余：`类加载方案`-即时性差
> 1. Sophix底层会判断机型是否支持热修复：如果机型底层虚拟机构造不支持，依旧走`类加载修复`

### 资源修复

23、热修复的方案大部分都参考了`Instant Run`的实现

#### Instant Run

24、Instant Run中的资源热修复的原理？
> 1. 构造一个新的`AssetManager`.
> 2. 反射调用`addAssetPath`，将这个完整的新资源包加入到`新AssetManager`中。
> 3. 找到所有引用`旧AssetManager`的地方，通过反射，将引用处替换为`新AssetManager`-该Manager包含所有新资源

25、Instant Run的资源热修复主要工作都是在处理`兼容性`和查找到AssetManager引用处，替换逻辑很简单。

#### Sophix方案

26、Sophix的资源修复方案
> 1. 构造一个`package id = 0x66`的资源包，包含两种资源：1.新增资源 2.原有内容发生改变的资源
> 1. 直接在原有AssetManager中addAssetPath`0x66资源包`，不和已经加载的0x7f冲突
> 1. 直接在原有的AssetManager对象上进行析构和重构。不再需要去找到所有`引用AssetManager的地方`

27、Sophix资源修复方案的优势
> 1. 不修改AssetManager的引用处，替换更快更安全(对比Instant Run以及所有copycat的实现)
> 1. 不必下发完整包，补丁包只包含改动的资源(对比Instant Run、Amigo等方式的实现)
> 1. 不需要在运行时合成完整包。不占用运行时资源。(对比Tinker的实现)

##### 不修改AssetManager的引用处

28、不修改AssetManager的引用处
> 直接在原有的AssetManager对象上进行析构和重构。不再需要去替换所有`旧AssetManager的引用`

##### 不必下发完整包

29、不必下发完整包
> 1. 构造一个`package id = 0x66`的资源包，包含`新增资源`和`原有内容发生改变的资源`
> 1. 直接在原有AssetManager中addAssetPath`0x66资源包`，会优先找到0x66资源包中的资源

##### 不需要在运行时合成完整包

30、不需要在运行时合成完整包
> 1. 采用dex文件级别的类插桩方案
> 1. 重新排列包中dex的顺序。虚拟机查找时优先找到classes.dex中的类，然后才是 classes2.dex、classes3.dex。系统自动实现类覆盖。


### SO库修复

31、SO库修复的原理
> 1. 本质是对native方法的修复和替换
> 1. 采用类似`类修复的反射注入方式`，把`补丁so库`的路径插入到`nativeLibraryDirectories数组`的最前方，这样加载so库的时候是补丁so库
> 1. 该方案在启动期间，反射注入补丁so库，而不是其他方案手动替换系统的`System.load()`来实现替换目的

## 代码热修复

### 底层热替换原理

#### Andfix即时生效的原理

##### navtive层替换掉原方法

1、Andfix的即时生效原理
> 1. Andfix即时生效，不需要重新启动，但是也有使用限制(不能增减方法和字段，只能替换掉原方法)。
> 1. 方法：在已经加载的类中，直接在navtive层替换掉原方法，

###### replaceMethod()

2、AndFix的核心：replaceMethod()
> 1. 获取到原有方法的`Method对象`，并且替换为新方法`dest`
> 1. 根据虚拟机类型是`art`还是`dalvik`，调用对应替换的方法(art/dalvik_replaceMethod)。
> 1. Android 4.4以下是dalvik， 4.4及以上是ART虚拟机
```java
@AndFix /src/com/alipay/enuler/andfix/AndFix.java
// src = 原有方法
// dest = 新方法
private static native void replaceMethod(Method src, Method dest);

@AndFix /jni/andfix.cpp
static void replacMethod(JNIEnv* env, jclass clazz, jobject src, jobject dest){
  is(isArt){
    art_replaceMethod(env, src, dest);
  }else{
    dalvik_replaceMethod(env, src, dest);
  }
}

@AndFix /jni/art/art_method_replace.cpp
extern void art_replaceMethod(JNIEnv* env, jobject src, jobject dest){
  if(apilevel > 23){
    replace_7_0(env, src, dest);
  }else if(apilevel > 22){
    replace_6_0(env, src, dest);
  }else if(apilevel > 21){
    replace_5_1(env, src, dest);
  }else if(apilevel > 19){
    replace_5_0(env, src, dest);
  }else{
    replace_4_4(env, src, dest);
  }
}
```

3、Android 6.0为例解析替换函数：replace_6_0
> 1. 每个Java方法在art中都一个对应的`ArtMethod`
> 1. `ArtMethod`记录着Java方法的所有信息：`所属类、访问权限、代码执行地址`等等。
> 1. 利用ArtMethod指针对所有成员进行修改。
> 1. 这样后续调用`该Java方法`就会走到`新的方法实现`中
```java
@AndFix /jni/art/art_method_replace_6_0.cpp
void replace_6_0(JNIEnv* env, jobject src, jobject dest){

  /**===========================================
   * 1、通过Method对象得到Java函数在底层对应的ArtMethod的真实地址
   *    1. 通过`FromReflectedMethod()`获得Method对象对应的ArtMethod的真实起始地址。
   *    2. 利用ArtMethod指针对所有成员进行修改。
   *=============================================*/
  art::mirror::ArtMethod* srcMeth = (art::mirror::ArtMethod*)env->FromReflectedMethod(src);
  art::mirror::ArtMethod* destMeth = (art::mirror::ArtMethod*)env->FromReflectedMethod(dest);

  /**===========================================
   * 2、将原方法的ArtMethod内部所有信息都替换为dest ArtMethod的内容
   *      1. 所属类
   *      2. 访问权限
   *      3. 代码执行地址
   *      ......
   *=============================================*/
   srcMeth->declaring_class_ = destMeth->declaring_class_;
   srcMeth->method_index_ = destMeth->method_index_;
   // xxx
}
```

###### ArtMethod

1、ArtMethod是什么？
> `ArtMethod`记录着Java方法的所有信息：`所属类、访问权限、代码执行地址`等等。

2、字段declaring_class就是方法所属的类
> 1. 类Student的test()方法的declaring_class就是Student.class

#### 虚拟机调用方法的原理

1、为什么替换了原Java方法对应的ArtMethod的内容就能实现热修复？虚拟机调用方法的原理？
> * Android6.0，art虚拟机中` ArtMethod`的结构如下：包含`方法的执行入口`
```java
@art /runtime/art_method.h

class ArtMethod FINAL{
  // 1、方法执行的入口
  void* entry_point_from_interpreter_;
  void* entry_point_from_quick_compiled_code_;
}
```
> * Java代码在Android中被编译为`Dex Code`，`art`中可以采用`解释模式`或者`AOT机器码模式`执行
>    1. 解释模式: 执行方法时，取出ArtMethod的`entry_point_from_interpreter_`的方法执行入口地址，跳转过去执行。
>    1. AOT机器码模式: 执行方法时，取出ArtMethod的`entry_point_from_quick_compiled_code_`的方法执行入口地址，跳转过去执行。
> * 简单的替换`entry_point_*`字段表明的入口地址，不能够`实现方法的替换`。
>     * 因为运行期间还会用到ArtMethod里面的`其他成员字段`
> * 即使是`AOT机器码模式`，编译出的`AOT机器码`的执行构成，依旧会有对`ArtMethod很多成员字段的依赖`
> * 结论：只有替换掉所有原ArtMethod中的成员字段，在所有执行到旧方法的地方，才能完整获取到所有新方法的信息: 执行入口、所属class、方法索引号、所属dex信息等，完美地去跳转到新方法。

##### 解释模式

2、什么是解释模式执行
> 1. 取出 DEX Code 逐条解释执行。

##### AOT机器码模式

3、说什么是AOT机器码模式
> 1. 预先编译好`Dex code`对应的`机器码`，运行时直接运行机器码

#### 兼容性问题的根源

4、AndFix等Hook方案采取的native替换的方法都具有不稳定性
> 1. 使用的`ArtMethod`结构完全根据`Android源码中ArtMethod`的结构写死的。
> 1. 一些厂商修改了`ArtMethod的内容和结构`就会导致`热修复失效---兼容性很差`

#### 突破底层结构的差异

##### ArtMethod整体替换

5、native替换方法的兼容性的解决办法
> 1. 原native替换方法是`替换ArtMethod`的所有成员，因此需要依赖具体结构。
> 1. 解决办法：不构造出`ArtMethod具体的成员字段`，将`ArtMethod进行整体替换`
```java
  memcpy(srcMeth, destMeth, sizeof(ArtMethod));
```

6、整体替换ArtMethod的核心在于如何精确计算出`sizeof(ArtMethod)`
> 1. 该整体替换ArtMethod的方案，在于如果`ArtMethod`的size计算有偏差，会导致：`部分成员没有替换、替换区域超出了边界`
> 1. 应用开发者无法知道具体Andorid设备的系统里`ArtMethod的尺寸`
> 1. 通过`class_linker.cc`源码中`LoadClassMembers()->AllocArtMethodArray()`中可以知道`ArtMethod Array(数组)`的`ArtMethod`是紧密相连的。通过相邻两个`ArtMethod`的`起始地址的差值`就是`ArtMethod的精准大小`
> 1. 类方法分为`Direct方法`和`Virtual方法`，各自有各自的`ArtMethod数组`
>      * direct方法: static方法和所有不可继承的对象方法
>      * virtual方法: 所有可以继承的对象方法

7、借助ArtMethod紧密相连的特性，如何精准计算出ArtMethod的大小?
> 1. 构造一个辅助的类，并具有两个空方法：
>    * f1()、f2()都是`static`方法，都属于`direct ArtMethod Array`
>    * NativeStructsModel中只有`这两个方法`，因此肯定是相邻的
```java
// f1()、f2()都是`static`方法，都属于
public class NativeStructsModel{
  final public static void f1(){}
  final public static void f2(){}
}
```
> 2. 在`JNI层`计算出`f1()和f2()`地址的差值。
```java
  size_t firstMid = (size_t) env->GetStaticMethodId(nativeStructModelClazz, "f1", "()V");
  size_t secondMid = (size_t) env->GetStaticMethodId(nativeStructModelClazz, "f2", "()V");
  // 第二个方法起始地址 - 第一个方法起始地址
  size_t methodSize = secondMid - firstMid;
```
> 3. 该`Size就可以直接作为ArtMethod的尺寸`
```c
//  memcpy(srcMeth, destMeth, sizeof(ArtMethod));

// 替换为:
  memcpy(srcMeth, destMeth, methodSize);
```

##### 唯一注意点

8、利用技巧获取到ArtMethod尺寸的优缺点
> 1. 优势：对于所有Android版本都不需要区分
> 1. 注意点：只要`ArtMethod数组`依旧是`线性结构`，无论`ArtMethod的成员`如何改变，都完美兼容。
> 1. `ArtMethod数组`的`线性结构`会被修改的可能性极低！

#### 访问权限

##### 方法调用时的权限检查

1、只替换ArtMethod的内容，被替换的方法有权限访问该类的其他private方法吗?
> 1. 可以
> 1. 在`dex2oat`生成`AOT机器码`时已经做过检查和优化，因此机器码中`不存在权限检查`
> 1. 例如下面：即使func()方法偷梁换柱为其他方法，依旧可以调用`private的func()`
```java
public class Demo{
  Demo(){
    func();
  }

  private void func(){
  }
}
```

##### 同包名下的权限问题

1、补丁中的类在访问同包名下的类时，会出现`访问权限异常`:
> 1. 具有类`com.patch.demo.BaseBug`和`com.path.demo.MyClass`是同一个包`com.patch.demo`下面的。
> 1. 此时替换了`com.patch.demo.BaseBug`的方法`test`，因为该方法的`ArtMethod`被完全替换，因此指向的是`新的补丁类`。
> 2. 该`补丁包中的BaseBug`是补丁包的`Classloader加载的`，和原先的包不是同一个Classloader，判定为不同包。`BaseBug.test()`中访问`MyClass类`，会导致提示无法访问`com.path.demo.MyClass`。
> 1. 校验逻辑在虚拟机代码的`Class::IsInSamePackage`中：会要求`Classloader`必须相同


2、只需要设置new Class的Classloader为old Class的Classloader就可以解决该问题:
> 1. 不需要在`JNI层`处理底层的结构
> 1. 只需要通过反射进行设置
```java
 // 1. 获取classloader的Field
 Field classLoaderField = Class.class.getDecalredField("classLoader");
 // 2. 允许访问权限
 classLoaderField.setAccessible(true);
 // 3. 将新类的classloader设置为旧类的classloader
 classLoaderField.set(newClass, oldClass.getClassLoader());
```

##### 反射调用非静态方法

1、非静态方法被热替换后，再反射调用该方法，会抛出异常。
> 1-下面会报错: `新BaseBug`的test()传入`旧BaseBug`，不匹配就会报错。
```java
  // BaseBug的test()方法已经被热替换
  // ...
  // 1、该对象bb是原始的BaseBug类对象
  BaseBug bb = new BaseBug();
  // 2、该test()是补丁包中BaseBug的test()方法
  Method testMeth = BaseBug.class.getDeclaredMethod("test");
  // 3、新BaseBug的test()传入就BaseBug，导致报错
  testMeth.invoke(bb);
```
> 2- invoke()->InvokeMethod()->VerifyObjectIsClass(): 会检测Method.invoke()参数传入的目标对象(旧类的对象)，是否是方法对应的ArtMethod所属的Class(新类)。
```java
// object = 旧类的对象bb
// C = ArtMethod的declaring_class = 新类
inline bool VerifyObjectIsClass(Object object, Class* c){
  if(UNLIKELY(!object->InstanceOf(c))){
    // 报错
    return flase;
  }
  // xxx
}
```

###### 静态方法不会有该问题

2、静态方法为什么不会有该问题？
> 是在`类的级别`直接调用的，不会接受`对象实例`作为参数，也不会有该方面的检查。

###### 解决办法

3、非静态方法被热替换后，再反射调用该非静态方法，会抛出异常。解决办法是：
> 冷启动机制

##### 即时生效的限制

1、即时生效这种运行期间修改底层结构的方案具有的限制有哪些？
> 1. 只能支持方法的替换：已存在类的方法增/减和字段增/减都不适用
> 1. 反射调用非静态方法会抛出异常

2、哪些场景是支持的？
> 1. 方法的替换
> 1. 新增一个完整的，原先包里不存在的新类

3、优点
> 1. 一旦符合使用条件，性能极佳，补丁小，加载迅速

4、不满足即时生效的场景该如何如何处理?
> 1. 冷启动修复

### 热修复与Java

#### 内部类编译

1、外部类有个方法，将其修改为访问内部类的某方法，会导致补丁包新增一个方法。

2、`内部类`在编译期会被编译为跟`外部类`一样的`顶级类`

##### 静态内部类和非静态内部类的区别

1、静态内部类和非静态内部类的区别
> 1. 静态内部类`不持有外部类的引用`
> 1. 非静态内部类会`持有外部类的引用`
> 1. 例如: handler的实现需要采用静态内部类，避免OOM

2、非静态内部类编译时会增加字段`this`用于持有外部类的引用

3、持不持有外部类引用，都不影响热部署。
> 都是一个顶级类，新增一个顶级类，不影响热部署

##### 内部类和外部类的互相访问

1、内部类和外部类都是顶级类，是否就表示对方private的内容无法被访问到？
> 1. 外部类需要访问内部类的`private 域/方法`，编译期间会为内部类生成`access&**`相关方法。
>     * 外部类就能访问内部类的private内容
> 1. 内部类需要访问`外部类`的`private 属性/方法`，编译期间会为外部类生成`access&**`相关方法。
>     * 内部类就能访问外部类的private内容

##### 热部署(底层替换方案)

2、补丁前的test()没有访问内部类的private属性/方法, 补丁后的test()访问了内部类的private属性/方法，会导致无法使用`热部署/底层替换方案`
> 1. 会新增`access&**`相关方法，按照限制，在原有类中增加方法，因此无法热部署
> 1. 只要避免生成`access&**`相关方法，就能走热部署。

3、如何避免编译器自动生成`access&**`相关方法
> 1. 如果一个外部类有内部类：
>    1. 把外部类所有`private属性/方法`的访问权限更改为其他权限(public、protected、default)
>    1. 把内部类所有`private属性/方法`的访问权限更改为其他权限(public、protected、default)


#### 匿名内部类编译

1、匿名内部类在避免新增`access&**`方法的基础上，依旧新增了一个内部类和新增了method方法
> 1. 热部署允许新增一个类
> 1. 热部署不允许新增方法

##### 编译期的命名规则

2、匿名内部类的名字格式是`外部类&`+`数字`
> 下例中：Thread的匿名内部类，编译期的名字为：`Demo&1`
```java
    public class Demo{
        public static void test(){

            new Thread(){
                // xxx
            }.start();
        }
    }
```
> 此时有两个顶级类

3、`原有的匿名内部类`前插入`新的匿名内部类`会导致混乱
> 1. 下例中：有两个匿名内部类
>      1. Demo&1 --- Callback.OnClickListener
>      2. Demo&2 --- Thread
> 2. 补丁会比较新的`Demo&1`和旧的`Demo&1`, 然而这两者完全不同。
>      1. 会新增OnClick()方法 --- 影响热部署(Demo&1中增加了新方法，删减了旧方法)
>      2. 会新增一个匿名内部类 --- 不影响，新增类没事(Demo&2)
```java
    public class Demo{
        public static void test(){

        // 新增一个内部类
            new Callback.OnClickListener{
              public void onClick(){
                // xxx
              }
            }


            new Thread(){
                // xxx
            }.start();
        }
    }
```

##### 热部署方案

1、在新增/减少匿名内部类时，如何支持热部署方案？
> 1. 唯一情况：增加的匿名内部类必须插入到`外部内末尾`
> 1. 其余情况：无解，补丁工具无法区分。


#### 域编译

##### 静态field初始化/静态代码块

1、热部署不支持`clinit`的修复
> 1. 热部署不支持`method/field`的新增
> 1. 热部署不支持`clinit`的修复

2、clinit在Dalvik虚拟机中类加载的时，进行类初始化时调用。

3、静态field初始化和静态代码块会被编译到`clinit`方法中
> 该方法由编译器自动合成

4、静态field初始化和静态代码块在`clinit`中的`顺序`取决于代码中出现的先后顺序

6、最常见的三种会去加载类的情况
> 1. new一个类对象(new-instance指令)
> 1. 调用类的静态方法(invoke-static指令)
> 1. 获取类的静态field的值(sget指令)

7、类没有被加载过时, 加载的流程
> 1. dvmResolveClass()
> 1. dvmLinkClass()
> 1. dvmInitClass(): 先对父类进行初始化，再调用本类的`clinit()`

##### 非静态field初始化/非静态代码块

8、非静态field初始化/非静态代码块会被编译到`init无参构造函数`中，顺序和源码中一致

9、构造函数会自动编译成init方法

##### 热部署方案

10、任何静态field初始化和静态代码块的变更都会编译到clinit中，无法热部署，只能冷启动(处于类加载的初始化期间)

11、非静态field初始化和非静态代码块的变更都会编译到init中，只被当作一个普通方法的变更，对热部署无影响(普通的方法)

#### final static field编译

1、`final static`修饰的field编译时是否会编译到`clinit`中？
> 1. 作为`静态域`，应该都被编译到`clinit`中，但是并不完全正确
> 1. 修饰的`基本类型/String常量类型`，不会编译到`clinit`中

2、下例中类中的field哪些会被编译到`clinit`方法中？哪些不会？
```java
public class Demo{

    static Object o1 = new Object(); // √
    final static Object o2 = new Object(); // √

    static int i1 = 1; // √
    final static int i2 = 2;// ×不会


    final static String s1 = new String("new String"); // √
    final static String s2 = "常量"; // ×不会
}
```
> 1. finalt static修饰的`基本类型和String常量类型`不会编译到`clinit`中

3、`final static`修饰的`基本类型/String常量类型`是在哪里初始化的？
> 1. 类加载初始化的`dvmInitClass`在执行`clinit`之前，调用`initSFields`对`static域设置默认值`。
> 1. `initSFields`设置默认值的目标包括`静态域的所有引用类型/基本类型/String常量类型`，但是`基本类型/String常量类型`在后面的`clinit`中就不会设置了

##### static和final static修饰的区别

1、static和final static修饰的区别
> 1. final static修饰的`原始类型和String类型(非引用类型)的field`，不会编译到`clinit`中，会提前在`类初始化执行的initSField`中进行初始化赋值。
> 1. final static修饰的`引用类型`和`static修饰的所有类型`，仍然在`clinit中初始化`

##### final static优化原理

1、对于常量使用`final static`修饰就能达到优化效果？
> 错误！
> * 只有`final static`修饰的`原始类型和tring类型常量`才能得到优化。

2、final static进行优化的原理
> 1. 可以优化的情况中：要访问该常量通过`const/4`指令实现，该指令非常简单
> 1. 不可优化的情况中：访问这些field，通过`sget`指令。内部包含解析，解析类等操作，属于重操作。

3、final对于final static修饰的引用类型的唯一作用就是避免该field被修改

##### 热部署方案

1、final static修饰的field如何进行热部署?
> 1. 可以热部署:
>      1. 基本类型: 引用该基本类型的地方都会被`立即数`替换
>      2. String常量：所有引用该常量的地方都被`常量池索引id`替换
>      3. 热部署中将所有引用到该`final static field`的方法都进行替换，走热部署没问题。
> 1. 不可热部署：
>      1. `final static`修饰的`引用类型`都被翻译到`clinit`中，不会热部署。

#### 方法编译

##### 混淆

1、混淆可能导致方法内联和裁剪，而导致`method`的增减

##### 方法内联

2、哪些场景会导致方法内联？
> 1. 方法没有被其他任何地方引用
> 1. 方法足够简单，例如只有一行，会在任何调用该方法的地方用该方法的实现进行替换
> 1. 方法只有一个地方引用到，会在调用处用实现进行替换

3、方法内联为什么会导致方法的增减？以及导致热部署失效？
> 1. 原Class中具有一个`test()`方法，因为内联，所以编译后不再有`test()方法`
> 1. 新Ckass中，因为不满足`内联的条件`导致`tets()不被内联`，因此多出来`test()方法`
> 1. 前后对比，因为`新增方法`导致不能`热部署`，只能`冷启动`
> 1. 反过来`方法内联`也会导致`方法的减少`

##### 方法裁剪

4、方法裁剪
> 1. `test(context)`方法中由于`context参数`没有被使用到，因此`混淆任务`会先生成`裁剪过后无参的test()方法`，然后再进行混淆。
> 1. 如果新代码中，正好使用了`参数`，不会导致方法裁剪，因此会新增一个`具有参数的test(context)`方法
> 1. 方法裁剪导致`方法增减`，导致`不嗯呢刚热部署`


5、如何避免方法裁剪？
> 1. 保证所有`参数被使用`，或者进行特殊处理：
```java
 public void test(Context context){
  if(Boolean.FALSE.booleanValue()){
    context.getApplicationContext();
  }
}
```

###### 代码规范

##### 热部署方案

1、如何避免混淆时的方法内联和方法裁剪导致热部署失效的问题？
> 混淆配置文件中加上配置项`-dontoptimize`就可以关闭方法的裁剪和内联

2、混淆库的预编译会拖累打包速度，Android虚拟机有自己的一套代码校验逻辑
> 需要加上配置项`-dontpreverify`

#### switch case语句编译

1、资源修复方案中需要对新旧ID进行替换，但是`switch case`中的`id`不会被替换

2、switch case 语句编译实例中解析编译规则
> 1-第一个方法较为连续。第二个方法不连续.
> 2-第一个testContinue()方法中，因为1、3、5连续，使用指令`packed-switch`，会影响`热部署`
> 3-第二个testNotContinue()中，1、3、10不连续，使用指令`sparse-switch`
```java
public void testContinue(){
    int temp = 2;
    int result = 0;
    switch (temp){
        case 1:
            result = 1;
            break;
        case 3:
            result = 1;
            break;
        case 5:
            result = 1;
            break;
    }
}

public void testNotContinue(){
    int temp = 2;
    int result = 0;
    switch (temp){
        case 1:
            result = 1;
            break;
        case 3:
            result = 1;
            break;
        case 10:
            result = 1;
            break;
    }
}
```

##### 热部署方案: 反编译

1、为什么资源id替换不完全？如何解决？
> 1. `资源id`肯定是`const final static`变量，导致`switch case`被翻译成`packed-switch`指令
> 1. 采用方案：`反编译(强行替换指令) -> 资源id替换 -> 重新编译`
>       1. 修改反编译流程： 遇到`packed-switch指令`就强转为`sparse-switch指令`；`:pswitch_N`等标签指令强转为`:sswitch_N`指令
>       1. 资源ID的暴力替换
>       1. 重新编译为`Dex`

#### 泛型

1、泛型可能会导致`method`的新增

##### 为什么需要泛型

2、Java中的泛型完全在`编译器`中实现
> 1. 由编译器执行`类型检查`和`类型推断`
> 1. 然后生成普通的无泛型的字节码。泛型知识为了保证类型安全。
> 1. 这种技术就是`擦除(erasure)`

3、Java的泛型为什么要采用`擦除技术`来实现？
> 1. 泛型从Java5才引入
> 1. 通过扩展虚拟机指令集来支持泛型是不可以的，也会导致升级JVM具有很多障碍

###### Object实现泛型

4、Object实现泛型
```java
public class ObjectGeneric {
    private Object obj;
    public void setValue(Object value){
        obj = value;
    }
    public Object getValue(){
        return obj;
    }

    public static void main(String args[]){
        ObjectGeneric generic = new ObjectGeneric();
        generic.setValue(true);
        // 1、获取数值
        boolean bool = (boolean) generic.getValue();
        // 2、获取到Int值
        int n = (int) generic.getValue();
    }
}
```
> 1. 上面1和2在编译期间都不会报错，因为符合Java语法。
> 1. 但是在实际运行中，`2`会出现`java.lang.ClassCastException`的异常:
```
Exception in thread "main" java.lang.ClassCastException: java.base/java.lang.Boolean cannot be cast to java.base/java.lang.Integer
	at ObjectGeneric.main(ObjectGeneric.java:16)
```

4、Java5泛型提出之前采用`Object`实现该效果，但是会导致`编译器`无法检测出`类型不匹配的问题`
> 泛型在`编译时`就进行`类型安全检测`

###### 泛型

5、泛型会在编译期间进行检查, 实例:
```java
public class ObjectGeneric<T> {
    private T obj;
    public void setValue(T value){
        obj = value;
    }
    public T getValue(){
        return obj;
    }

    public static void main(String args[]){
        ObjectGeneric<Boolean> generic = new ObjectGeneric();
        generic.setValue(true);
        // 1、获取数值
        boolean bool = (boolean) generic.getValue();
        // 2、获取到Int值
        // int n = (int) generic.getValue();
    }
}
```
> 情况2获取到Int值，会报错。

##### 类型擦除

1、下面的例子中的类型擦除:
> 1. 方法`setValue(T value)`会被处理为`setValue(Object value)`, 因此编写一个方法为`setValue(Object value)`会`报错！`
> 1. 泛型设置类具体类型`<Integer>`本质在字节码中生成的还是`Object类型的参数`，只是利用这个进行了类型检查。
```java
public class ObjectGeneric<T> {
    private T obj;
    public void setValue(T value){
        obj = value;
    }

    // 报错：Error:(9, 17) java: 名称冲突: setValue(java.lang.Object)和setValue(T)具有相同
    public void setValue(Object value){
        obj = value;
    }

}
```

##### 类型擦除和多态的冲突

2、类型擦除会导致本来是想`重写`，结果变成了`重载`
> 1. `setValue(T value)`在字节码上是`setValue(Object obj)`
> 1. 结果`setValue(Integer value)`是对父类`setValue(Object obj)`的重载
> 1. 然而需要的效果是`setValue(Integer value)`是对父类`setValue(T obj)`的重写
```java
public class ObjectGeneric<T> {
    private T obj;
    public void setValue(T value){
        obj = value;
    }
    public T getValue(){
        return obj;
    }

    class B extends ObjectGeneric<Integer>{
        private Integer n;
        public void setValue(Integer value) {
            n = value;
        }
    }
}
```

3、使用 `@Override`能实现`重写`
```java
    class B extends ObjectGeneric<Integer>{
        private Integer n;

        @Override
        public void setValue(Integer value) {
            n = value;
        }
    }
```

###### bridge

4、编译器会自动合成bridge方法来实现`重写`的效果
> 编译器自动生成一个`setValue(Object Value)`来重写`父类`的该方法
```java
    class B extends ObjectGeneric<Integer>{
        private Integer n;

//        public void setValue(Object obj){
//            // xxx
//        }

        @Override
        public void setValue(Integer value) {
            n = value;
        }

// 自动生成
//        public void setValue(Object value){
//            n = value;
//        }
    }
```

5、虚拟机是通过`参数类型+返回类型`来确定一个方法，和Java语言规则不同。
> 该方法用于解决泛型中类型擦除和多态的冲突问题

6、泛型的隐形类型转换，编译器会自动加上`check-cast`类型转换
> 不需要程序员进行`显式地类型转换`，而是自动进行类型转换。
```java
    public static void main(String args[]){
        ObjectGeneric<Boolean> generic = new ObjectGeneric();
        generic.setValue(true);
        // 1、获取数值
        boolean bool = generic.getValue();
    }
```

##### 热部署的方案

1、泛型对热部署的影响
> 1. 类型擦除的过程中可能会`新增bridge方法`，导致热部署失败
> 1. 另一方面`泛型方法内部`会生成一个`dalvik/annotation/Signature`的系统注解，方法逻辑没出现变化，但是该方法的注解发生了变化。补丁工具进行判断会走`热部署进行修复`，然而并没有什么意义(方法逻辑没有变化，根本不需要修复)

#### Lambda表达式编译

1、Lambda表达式简介
> 1. Java 7 才引入的一种表达式
> 2. 类似`匿名内部类`，却`有巨大的区别`
> 1. `会导致方法的增减`，影响热部署

2、函数式接口的两大特征
> 1. 是一个街口
> 1. 具有唯一的一个抽象方法
> 1. 典型的函数式接口`Runnable和Comparator`

##### 和匿名内部类的区别
3、Lambda表达式和匿名内部类的区别?
> 1. 关键字this:
>      1. 匿名内部类的this指向`匿名类`
>      1. lambda表达式的this指向`包围lambda表达式的类`
> 1. 编译方式:
>      1. 编译器将`匿名内部类`编译成`新类`，名称为`外部类名+&number`
>      1. 编译器将`lambda表达式`编译成`类的私有方法`，使用`Java7的invokedynamic`字节码指令进行动态绑定该方法

###### invokedynamic

4、实例解析lanmbda表达式
> 1. 编译期间会自动生成私有静态的`lambda$test$ + number(参数类型)`的方法
> 1. invokedynamic执行`lambda表达式`
> 1. 相比于`匿名内部类`，不会生成`外部类名 + & + number`的新类。
```java
public class Test{
  public static void test(){
    new Thread( ()->{
          // xxx
    }).start();
  }
}
```

##### metafctory

5、invokedynamic指令简介
> 1. java7新增，用于支持`动态语言`：`允许方法调用可以在运行时指定类和方法`，不需要编译时确定。
> 1. 每个`invokedynamic`指令出现的位置被称为`动态调用点`
> 1. `invokedynamic`指令后会跟着一个`指向常量池的调用点限定符(#3, #6)`
> 1. `调用点限定符`会被解析为`一个动态调用点`
> 1. `invokedynamic指令`最终会去执行`java.lang.invoke.LambdaMetafactory类`的`静态方法: metafctory()`，该方法`会在运行时声称一个实现函数式接口的具体类`
> 1. 该`具体类-例如: Test$$Lambda$1.java` 会调用`私有静态方法： lambda$test$ + number(参数类型)`，执行`lambda表达式的逻辑`
```java
final class Test$$Lambda$1 implements Runnable{
  @Hidden
  public void run(){
    // 去执行自动生成的lambda表达式相关的方法，该方法内部就是自定义的逻辑
    Test.lambda$test$0();
  }
}
```

##### Android虚拟机中的lambda

1、Android虚拟机下是如何解释lambda表达式的？
> 1. android虚拟机`首先通过javac把源代码.java编译成.class`,`在通过dx工具优化成适合移动设备的dex字节码文件`
> 1. android中`如果要使用java8语言特性`，需要使用`新的jack工具链`来替代老的工具链进行`编译`
> 1. `Jack`会将`.java文件`编译成`.jack`文件，最后直接编译成`.dex`文件(Dalvik字节码文件)


2、构建`Android Dalvik可执行文件`可使用的两种工具链对比
> 1. 旧版javac工具链
>      `javac`(.java -> .class)->`dx`(.class ->. dex)
> 1. 新版Jack工具链
>      `Jack`(.java -> .class -> .dex)

###### Jack

1、Jack是什么?
> Java Android Compiler Kit

2、Jack工具链中处理lambda的异同
> 1. 相同点:
>    * 编译期间都会`为外部类合成一个static辅助方法`，内部逻辑就是`lambda表达式的内容`
> 1. 不同点:
>    1. 老版本中通过`invokedynamic指令`执行`lambda`; Jack的`.dex`中执行`lambda表达式`和`普通方法调用没有区别`
>    1. 老版本是在`运行中生成新类`；Jack是在`编译期间`生成`新类`

##### 热部署方案

1、Lambda表达式会导致热部署失效的原因
> 1. 方法的增减: 新增一个lambda表达式，会导致`外部类新增一个辅助方法`
> 1. 顺序混乱: 合成类的命名规则 = “外部类雷鸣 + Lambda + Lambda所在方法的签名 + LambdaImpl + `出现的序号`”，和`匿名内部类一样的问题`

2、不增减lambda表达式，不改变lambda表达式的顺序，只是更改Lambda原有内部逻辑，能否走热部署?
> `在一定情况下，依旧会出问题，不能走热部署`:
> 1. 如果`lambda表达式`访问`外部类非静态的field和method`
>       1. `编译期间在.dex文件`中会自动生成`新的辅助类(Test$$Lambda$1.java)`, 该类`没有持有外部类的引用`
>       1. 为了访问非静态的field和method，会导致`需要持有外部类的引用，从而增加一个字段来持有`
> 1. `辅助类的field的增减`导致无法热部署
```java
final class Test$$Lambda$1 implements Runnable{
  @Hidden
  public void run(){
    // 去执行自动生成的lambda表达式相关的方法，该方法内部就是自定义的逻辑
    Test.lambda$test$0();
  }
}
```

3、Lambda表达式对热部署影响的总结
> 1. `增加/减少`一个lambda表达式会导致`类方法的错乱`。热部署失败！
> 1. `修改`一个原有lambda表达式，因为可能访问/取消访问`外部类的非静态field和method`的情况，可能导致`辅助类的field`的`增加/减少`。热部署失败！
> 1. `调整原有lambda表达式的顺序`，会导致`类方法的错乱`。热部署失败！

#### 访问权限检查

1、一个类的加载必须经历`resolve`、`link`、`init`三个阶段

##### 类加载阶段

1、类加载阶段中对父类和当前类实现的接口的权限检查主要在link阶段
> 1. 如果当前类、实现的接口、父类是非public的，并且加载两者的`classLoader`不一样的情况，直接return
> 1. 代码热修复方案是基于新classLoader的，类加载阶段就会报错

##### 类校验阶段

2、如果补丁类中存在非public类的访问、非public方法的调用、非public field的调用都会导致失败
> 1. 这些错误在`补丁加载阶段`是检测不出来的，补丁会被视作正常加载
> 1. 直到运行阶段，会直接crash


### 冷启动类加载原理

1、冷启动方案的作用?
> 1. 热部署有很多限制
> 1. 在超出限制的情况下，再通过冷启动进行补充，使得热修复一定能成功。

#### 传统实现方案

##### Tinker

1、Tinker如何实现冷启动的?
> 1. 提供Dex差量包，并整体替换Dex的方案。
> 1. 通过差量的方式生成patch.dex(补丁dex文件)，然后将`patch.dex`和应用的`classes.dex`合并成一个完整的dex
> 1. 加载`新dex文件`得到`dexFile对象`并以此构造出`Element对象`，然后整体替换掉`旧的dex Elements数组`


2、Tinker方案的优点
> 1. 自研dex差异算法，补丁包小，不影响类加载性能。

3、Tinker方案的缺点
> dex合并，在VM Heap上消耗内存，容易OOM，导致dex合并失败

4、Tinker如何避免OOM导致的dex合并失败的问题?
> 1. 可以在jni层面进行dex的合并，从而避免OOM导致dex合并失败
> 1. 但是JNI层实现比较复杂。

#### 插桩实现

5、如果仅仅把补丁类打入补丁包中而不做任何处理会出什么问题？
> 运行时`类加载`的时候会异常退出

6、加载一个dex文件到本地内存的流程
> 1. 如果不存在`odex文件`，首先会执行`dexopt`
> 1. `dexopt`的入口在`davilk/opt/OptMain.cpp`的`main方法`
> 1. 最后调用`verifyAndOptimizeClass`进行真正的`verify(验证)和optimize(优化)`操作

##### odex

##### dexopt

1、dexopt的流程
![dexopt](https://github.com/FeatherHunter/StudyNotes/blob/master/assets/android/sophix/hotfix_dexopt.PNG?raw=true)

##### verifyAndOptimizeClass

1、Apk第一次安装时的流程
> 1. 对原Dex执行`dexopt`->`执行到verifyAndOptimizeClass()`
> 1. 会先进行`类校验-dvmVerifyClass()`: 校验成功，则所有类都会打上`CLASS_ISPREVERIFIED`标志
> 1. 接着执行`类优化-dvmOptimizeClass()`，并且打上`CLASS_ISOPTIMIZED`标志

##### dvmVerifyClass

1、dvmVerifyClass()方法的作用
> 1. 类校验，目的是: 防止类被篡改校验类的合法性
> 1. 会对`类的每个方法`进行校验，`类的所有方法`中`直接`引用的类和当前类都在同一个dex中：return true


##### dvmOptimizeClass
1、dvmOptimizeClass()方法的作用
> 1. 类优化，将部分指令优化成`虚拟机的内部指令`
> 1. 例如: 方法调用指令
>        1. `invoke-*`指令变成了`invoke-*-quick`指令
>        1. quick指令直接从`vtable`表中取，该表是类的所有方法的表(包括继承的方法)，`加快了方法的执行速度`


##### dvmResolveClass

1、加载阶段中为什么会出现`dvmThrowllegalAccessError`(运行时异常)?
> 1. 原Dex中的`类B`中的某个方法引用到`补丁包中的类A`
> 1. 执行到该方法时，会尝试解析类A:
>       1. 类B具有`CLASS_ISPREVERIFIED`标志
>       1. 然后判断`类A`和`类B`所属的`dex`，因为不同，抛出异常`dvmThrowllegalAccessError`

2、为什么原Dex类B能引用到补丁类A的方法？明明没打补丁前，都不知道有这个补丁类A？

###### 插桩

1、如何解决dvmThrowllegalAccessError问题？
> 1. 构造一个单独没啥用的`帮助类`放到一个单独的Dex中
> 1. 原Dex中所有类的构造函数都引用这个类
> 1. 这里需要侵入dex打包流程，利用`.class字节码修改技术`，在所有`.class`文件的构造函数中引用该`帮助类`
> 1. 在加载Dex文件时，会走dexopt流程，在`dvmVerifyClass`校验时，校验失败(类B的所有方法中引用到的类-帮助类，和类B不在一个Dex中)。原dex中所有类没有`CLASS_ISPREVERIFIED`标志。并且后续流程也不走，不会打上`CLASS_ISOPTIMIZED`
> 1. 因此引用到补丁类A时，解析类A，不会进入`CLASS_ISPREVERIFIED`标志的后续判断，也不会抛出异常`dvmThrowllegalAccessError`

#### 插桩导致类加载性能差

1、插桩为什么会导致类加载的效率很低？
> 1. 类的加载需要三个阶段：dvmResolveClass->dvmLinkClass->dvmInitClass
> 1. 如果类因为插桩没有打上`CLASS_ISPREVERIFIED`和`CLASS_ISOPTIMIZED`标志，在类的初始化阶段，还会重新进行`类的verify(验证)和optimize(优化)`
> 1. 原来验证和优化操作只有在第一次apk安装执行dexopt时，才会进行。结果如今每次进行类加载时，都会重复处理，过多的类加载同时进行，性能消耗会更大。

##### 插桩具体性能影响

1、插桩技术对性能影响的具体测试数据
> 1. 整体上有8~9倍的性能差距
> 1. 应用启动上，容易导致白屏。
||不插桩|插桩|
|---|---|---|
|加载700个类   | 84ms  | 685ms  |
|启动应用耗时   |4934ms   |7240ms   |

#### 避免插桩的手Q方案

1、手Q方案中避免插桩的思路是什么？
> 1. 避免在`dvmResolveClass`中走校验dex一致性的流程.
> 1. 也就是提前将`补丁类`加入到数组中，让其能直接返回`补丁类`
```java
    void dvmResolve(){

        ClassObject patchClass = null;

        // 1、提前将patch类加入到数组中，让patchClass!=null。
        patchClass = dvmDexGetResolved(xxx);
        if(patchClass != null){
            // 2、只要这里拿到了patchClass，就可以直接返回。
            return patchClass;
        }

        // 3、检查dex的一致性
        // xxx
        // throw dvmThrowIllegalAccessError

    }
```

2、手Q方案的缺陷?
> 1. 在`dexopt`后进行绕过的，dexopt会改变原先的很多逻辑
> 1. odex层面的优化会写死字段和方法的访问偏移，就会导致严重的BUG

#### ART下冷启动实现

##### Dalvik和Art加载dex分解的区别

1、Dalvik只会把`classes.dex`文件加载到内存中
> 1. 如果压缩文件中有多个dex文件，除了`classes.dex`文件，其他的dex文件都会被无视

2、Art支持压缩文件中包含多个dex的加载问题
> 1. 会优先加载`classes.dex`文件
> 1. 然后在按顺序加载`classes2.dex`、`classes3.dex`文件
> 1. 如果多个dex中有同一个`类`，只有第一个出现的`类`才会被加载，不会重复加载


##### Art中的方案

3、Art中进行冷启动的方案
> 1. 把`补丁dex`文件命名为`classes.dex`
> 1. 原`apk`中的`dex`依次命名为`classes(2,3,4...).dex`，并一起打包为一个压缩文件。
> 1. 再通过`DexFile.loadDex()`得到`DexFile对象`，并将其整个替换`旧的dexElements数组`即可

4、Art冷启动方案的注意点
> 1. 补丁dex必须命名为`classes.dex`
> 1. loadDex得到的新DexFile必须完全替换掉dexElements数组，而不是插入

###### Tinker方案的比较

4、Tinker的冷启动方案和Sophix新方案的比较图
![Tinker的冷启动方案和Sophix新方案的比较图](https://github.com/FeatherHunter/StudyNotes/blob/master/assets/android/sophix/hotfix_art_coldfix_tinker.PNG?raw=true)

#### odex和dex

5、虚拟机真正执行的是dex文件吗?
> 1. `DexFile.loadDex()`会尝试将`dex文件`解析并加载到`native内存中`
> 1. 如果`native内存中`不存在dex对应的odex，Dalvik和Art分别通过`dexopt`、`dexoat`得到一个优化后的`odex`
> 1. VM真正执行的是`odex`还不是`dex`

#### 完整的方案

6、Dalvik和Art中完美兼容的冷启动方案
> 1. 代码采用同一套，不会根据Dalvik和Art分开处理。
> 1. Dalvik: 采用自行研发的全量Dex方案
> 1. Art：本身支持多Dex加载，只需要改名即可。

### 多态对冷启动类加载的影响

#### 多态

#### 冷启动方案的限制

#### 终极方案

### Dalvik中全量Dex方案

#### 冷启动类加载修复

#### 新的全量Dex方案

#### 对Application的处理

#### dvmOptResolveClass的问题

## 问题汇总

## 参考资料

1. [混淆库官方文档](https://www.guardsquare.com/en/products/proguard/manual/introduction)
1. [Android 新一代编译 toolchain Jack & Jill 简介](http://taobaofed.org/blog/2016/05/05/new-compiler-for-android/)
1. [官方文档Compiling with Jack](https://source.android.com/source/jack.html)
1. [gradle中如何使用Lambda](https://developer.android.com/guide/platform/j8-jack.html?hl=zh-cn)
