
转载请注明链接:https://blog.csdn.net/feather_wch/article/details/87910364

# 热修复原理

版本号:2019/2/25-20:00

---

@[toc]

---

## 技术介绍

### 热修复基本概念

1、传统BUG修复流程的弊端?
> 1. 重新发布版本代价太大
> 2. 用户下载安装成本太高
> 1. BUG修复不及时，用户体验差。

2、对于这些弊端，有哪些合适的解决办法?(or 有哪些方案能够进行BUG的快速修复？)
|方案|内容|缺点|
|---|---|---|
|Hybird方案   |将需要经常变更的业务逻辑通过H5进行独立   |1. 有学习成本，需要对原有逻辑进行合理的抽象和转换。 2. 对于无法转为H5的代码依旧无法修复   |
|插件化方案   |例如`Atlas`以及`DroidPlugin`方案   |1.移植成本高 2.需要学习插件化工具 3. 改造老代码的功能量大|
|热修复   |APP直接从云端下拉补丁和更新   |   |

#### 三大优势

3、热修复的3大优势
> 1. 无需重新发版，实时高效热修复。
> 1. 用户无感知修复，无需下载新的应用，代价小。
> 1. 修复成功率高

#### 三大领域

4、Android 热修复的3大领域
> 1. 代码修复
> 1. 资源修复
> 1. so修复

#### 传统框架实现方式

5、传统热修复框架的实现方式
|框架|方案|缺点|
|---|---|---|
|Xposed   |手淘，`底层结构替换方案`，针对Dalvik虚拟机开发的Java Method Hook技术-Dexposed   |1.对于底层Dalvik结构过于依赖   2.无法继续兼容ART虚拟机(Android 5.0起)|
|Andfix   |支付宝，`底层结构替换方案`，做到了Dalvik和ART环境的全版本兼容。   |   |
|Hotfix   |阿里百川，Andfix升级版，业务逻辑解耦   |1.`底层结构的替换方案``稳定性差`  2.使用范围限制多 3.不支持资源和so修复|
|超级补丁技术   |QQ控件   |   |
|Tinker   |微信，   |   |
|Amigo   |饿了么，   |   |
|Robust   |美团，   |   |


#### Sophix概览

6、Sophix的设计理念
> 1. 核心理念：非侵入性
> 1. 打包过程不会侵入到apk的build流程中。也不会增加任何AOP代码，对开发者透明化。

##### 优势

7、Sophix框架的优势
> 1. 支持代码修复、资源修复、so修复
> 1. 集成非常简单，没有侵入性。


##### 缺点

8、Sophix的缺点
> 1. 唯一缺点，是不支持四大组件的增加。但是支持四大组件的增加必然导致代码侵入性过强。
> 1. 一般热修复也使用于修复故障。而不是增加很多新功能。因此也不需要。
> 1. 可以通过增加Fragment，增加新功能。


### 代码修复

9、代码修复的两大主要方案
> 1. 阿里系的`底层替换方案`。
> 1. 腾讯系的`类加载方案`。

10、底层替换方案和类加载方案的优劣
|方案|优点|缺点|
|---|---|---|
|底层替换   |1.时效性最好 2.加载轻快 3.立即见效   |限制很多   |
|类加载   |1.修复范围广 2.限制少   |1.时效性差，需要冷启动才能见效   |

#### 底层替换方案

##### 传统方案

11、底层替换方案是什么?
> 1. 在已经加载了的类中直接替换掉原有的方法
> 1. 是在原有类的基础上进行的修改，因此无法进行`方法`和`字段`的增减(这会破坏原有类的结构)
> 1. 该方案的底层替换具有`不稳定性`

###### 类方法的增减

12、为什么底层替换方案无法增减原有类的方法？
> 1. 会导致`该类`和`整个Dex`的`方法数`变化
> 1. `方法数的变化`会造成`方法索引的变化`，这样访问方法时，就无法正常所引导正确的方法。

###### 类字段的增减

13、为什么底层替换方案无法增减原有类的字段？
> 1. 增加和减少了`字段`和增减方法一样，会导致`所有字段`的索引发生变化。
> 1. `最严重的是`, 在app运行时某个类突然增加了字段，而原先已经产生的该类的实例还是`原来的结构`(这是无法改变的)，后续对这个老实例对象访问`新增字段`是很致命的。


###### 不稳定性

14、底层替代方案是如何实现的？
> 1. 无论是`Dexposed`、`AndFix`以及其他的`Hook方案`都是直接修改虚拟机方法的具体字段。
> 1. 例如修改`Dalvik`方法的`jni函数指针`、修改类的访问权限、修改方法的访问权限

15、底层替代方案的不稳定性?
> 1.这种依赖于具体字段的Hook方案，各个厂商会对源代码进行改造，从而导致不匹配。
> 1. 例如`Andfix`里`ArtMethod的结构`是根据开源Android源码中的结构写死的。如果结构发生改变，就会导致`替换机制`出错。

##### 无视底层结构的替换方案

16、无视底层具体结构的替换方法
> 1. 忽略底层`ArtMethod`结构的差异
> 1. 所有Android版本都不需要区分
> 即使Android版本不断修改ArtMethod的成员，只要保证ArtMethod数据仍然是`线性结构排序`就没问题

#### 类加载方案

##### 传统方案的原理

17、传统类加载方案原理是什么?
> 1. app重新启动后让`ClassLoader`去加载新的类
> 1. 不重启app，原来的类还在虚拟机中，就无法加载新的类。

18、腾讯系三类加载方案的实现原理
> 1. QQ控件会侵入打包流程，增加无用信息，不优雅。
> 1. QFix方案，获取底层虚拟机的函数，不够稳定可靠，且无法新增public函数
> 1. 微信Tinker，完整的`全量Dex加载`。会对Dex内容非常精细的比较(方法和指令的维度)，性能消耗严重。

##### Dex比较维度

19、Dex的比较维度有三种
> 1. 方法和指令的维度: 粒度过细，性能差
> 1. bsbiff: 粒度粗糙
> 1. 类的维度: 粒度最合适，能够达到`时间和空间平衡`的最佳效果

##### Sophix的方案

20、Sophix的类加载方案
> 1. dex的比较维度：类的维度
> 1. 采用全量合成dex:
>     1. 利用Android原先的类查找和合成机制，快速合成新的全量Dex-不需要处理合成时方法数超过的问题，也不会破坏性重构dex的结构。
>     1. 重新排列包中dex的顺序。虚拟机查找时优先找到classes.dex中的类，然后才是 classes2.dex、classes3.dex

###### 类插桩


21、Sophix中的dex文件级别的类插桩方案
> 1. 将`旧包`和`补丁包`中的classes.dex的顺序进行了重排
> 1. 让系统自动实现类覆盖的目的，大大减少合成补丁的开销

#### 双剑合璧

22、两个方案的合并
> 1. 底层替换方案和类加载方案合并使用
> 1. 补丁工具根据实际代码变动情况：
>         1. 小修改，在底层替代方案的适用范围内：`底层替代方案`-即时生效
>         1. 其余：`类加载方案`-即时性差
> 1. Sophix底层会判断机型是否支持热修复：如果机型底层虚拟机构造不支持，依旧走`类加载修复`

### 资源修复

23、热修复的方案大部分都参考了`Instant Run`的实现

#### Instant Run

24、Instant Run中的资源热修复的原理？
> 1. 构造一个新的`AssetManager`.
> 2. 反射调用`addAssetPath`，将这个完整的新资源包加入到`新AssetManager`中。
> 3. 找到所有引用`旧AssetManager`的地方，通过反射，将引用处替换为`新AssetManager`-该Manager包含所有新资源

25、Instant Run的资源热修复主要工作都是在处理`兼容性`和查找到AssetManager引用处，替换逻辑很简单。

#### Sophix方案

26、Sophix的资源修复方案
> 1. 构造一个`package id = 0x66`的资源包，包含两种资源：1.新增资源 2.原有内容发生改变的资源
> 1. 直接在原有AssetManager中addAssetPath`0x66资源包`，不和已经加载的0x7f冲突
> 1. 直接在原有的AssetManager对象上进行析构和重构。不再需要去找到所有`引用AssetManager的地方`

27、Sophix资源修复方案的优势
> 1. 不修改AssetManager的引用处，替换更快更安全(对比Instant Run以及所有copycat的实现)
> 1. 不必下发完整包，补丁包只包含改动的资源(对比Instant Run、Amigo等方式的实现)
> 1. 不需要在运行时合成完整包。不占用运行时资源。(对比Tinker的实现)

##### 不修改AssetManager的引用处

28、不修改AssetManager的引用处
> 直接在原有的AssetManager对象上进行析构和重构。不再需要去替换所有`旧AssetManager的引用`

##### 不必下发完整包

29、不必下发完整包
> 1. 构造一个`package id = 0x66`的资源包，包含`新增资源`和`原有内容发生改变的资源`
> 1. 直接在原有AssetManager中addAssetPath`0x66资源包`，会优先找到0x66资源包中的资源

##### 不需要在运行时合成完整包

30、不需要在运行时合成完整包
> 1. 采用dex文件级别的类插桩方案
> 1. 重新排列包中dex的顺序。虚拟机查找时优先找到classes.dex中的类，然后才是 classes2.dex、classes3.dex。系统自动实现类覆盖。


### SO库修复

31、SO库修复的原理
> 1. 本质是对native方法的修复和替换
> 1. 采用类似`类修复的反射注入方式`，把`补丁so库`的路径插入到`nativeLibraryDirectories数组`的最前方，这样加载so库的时候是补丁so库
> 1. 该方案在启动期间，反射注入补丁so库，而不是其他方案手动替换系统的`System.load()`来实现替换目的

## 代码热修复

### 底层热替换原理

#### Andfix即时生效的原理

1、Andfix的即时生效原理
> 1. Andfix即时生效，不需要重新启动，但是也有使用限制(不能增减方法和字段，只能替换掉原方法)。
> 1. 方法：在已经加载的类中，直接在navtive层替换掉原方法，

##### replaceMethod()

2、AndFix的核心：replaceMethod()
> 1. 获取到原有方法的`Method对象`，并且替换为新方法`dest`
> 1. 根据虚拟机类型是`art`还是`dalvik`，调用对应替换的方法(art/dalvik_replaceMethod)。
> 1. Android 4.4以下是dalvik， 4.4及以上是ART虚拟机
```java
@AndFix /src/com/alipay/enuler/andfix/AndFix.java
// src = 原有方法
// dest = 新方法
private static native void replaceMethod(Method src, Method dest);

@AndFix /jni/andfix.cpp
static void replacMethod(JNIEnv* env, jclass clazz, jobject src, jobject dest){
  is(isArt){
    art_replaceMethod(env, src, dest);
  }else{
    dalvik_replaceMethod(env, src, dest);
  }
}

@AndFix /jni/art/art_method_replace.cpp
extern void art_replaceMethod(JNIEnv* env, jobject src, jobject dest){
  if(apilevel > 23){
    replace_7_0(env, src, dest);
  }else if(apilevel > 22){
    replace_6_0(env, src, dest);
  }else if(apilevel > 21){
    replace_5_1(env, src, dest);
  }else if(apilevel > 19){
    replace_5_0(env, src, dest);
  }else{
    replace_4_4(env, src, dest);
  }
}
```

3、Android 6.0为例解析替换函数：replace_6_0
> 1. 每个Java方法在art中都一个对应的`ArtMethod`
> 1. `ArtMethod`记录着Java方法的所有信息：`所属类、访问权限、代码执行地址`等等。
> 1. 利用ArtMethod指针对所有成员进行修改。
> 1. 这样后续调用`该Java方法`就会走到`新的方法实现`中
```java
@AndFix /jni/art/art_method_replace_6_0.cpp
void replace_6_0(JNIEnv* env, jobject src, jobject dest){

  /**===========================================
   * 1、通过Method对象得到Java函数在底层对应的ArtMethod的真实地址
   *    1. 通过`FromReflectedMethod()`获得Method对象对应的ArtMethod的真实起始地址。
   *    2. 利用ArtMethod指针对所有成员进行修改。
   *=============================================*/
  art::mirror::ArtMethod* srcMeth = (art::mirror::ArtMethod*)env->FromReflectedMethod(src);
  art::mirror::ArtMethod* destMeth = (art::mirror::ArtMethod*)env->FromReflectedMethod(dest);

  /**===========================================
   * 2、将原方法的ArtMethod内部所有信息都替换为dest ArtMethod的内容
   *      1. 所属类
   *      2. 访问权限
   *      3. 代码执行地址
   *      ......
   *=============================================*/
   srcMeth->declaring_class_ = destMeth->declaring_class_;
   srcMeth->method_index_ = destMeth->method_index_;
   // xxx
}
```

###### ArtMethod

1、ArtMethod是什么？
> `ArtMethod`记录着Java方法的所有信息：`所属类、访问权限、代码执行地址`等等。

#### 虚拟机调用方法的原理

1、为什么替换了原Java方法对应的ArtMethod的内容就能实现热修复？虚拟机调用方法的原理？
> * Android6.0，art虚拟机中` ArtMethod`的结构如下：包含`方法的执行入口`
```java
@art /runtime/art_method.h

class ArtMethod FINAL{
  // 1、方法执行的入口
  void* entry_point_from_interpreter_;
  void* entry_point_from_quick_compiled_code_;
}
```
> * Java代码在Android中被编译为`Dex Code`，`art`中可以采用`解释模式`或者`AOT机器码模式`执行
>    1. 解释模式: 执行方法时，取出ArtMethod的`entry_point_from_interpreter_`的方法执行入口地址，跳转过去执行。
>    1. AOT机器码模式: 执行方法时，取出ArtMethod的`entry_point_from_quick_compiled_code_`的方法执行入口地址，跳转过去执行。
> * 简单的替换`entry_point_*`字段表明的入口地址，不能够`实现方法的替换`。
>     * 因为运行期间还会用到ArtMethod里面的`其他成员字段`
> * 即使是`AOT机器码模式`，编译出的`AOT机器码`的执行构成，依旧会有对`ArtMethod很多成员字段的依赖`
> * 结论：只有替换掉所有原ArtMethod中的成员字段，在所有执行到旧方法的地方，才能完整获取到所有新方法的信息: 执行入口、所属class、方法索引号、所属dex信息等，完美地去跳转到新方法。

##### 解释模式

2、什么是解释模式执行
> 1. 取出 DEX Code 逐条解释执行。

##### AOT机器码模式

3、说什么是AOT机器码模式
> 1. 预先编译好`Dex code`对应的`机器码`，运行时直接运行机器码

#### 兼容性问题的根源

4、AndFix等Hook方案采取的native替换的方法都具有不稳定性
> 1. 使用的`ArtMethod`结构完全根据`Android源码中ArtMethod`的结构写死的。
> 1. 一些厂商修改了`ArtMethod的内容和结构`就会导致`热修复失效---兼容性很差`

#### 突破底层结构的差异

5、native替换方法的兼容性的解决办法
> 1. 原native替换方法是`替换ArtMethod`的所有成员，因此需要依赖具体结构。
> 1. 解决办法：不构造出`ArtMethod具体的成员字段`，将`ArtMethod进行整体替换`
```java
  memcpy(srcMeth, destMeth, sizeof(ArtMethod));
```

6、整体替换ArtMethod的核心在于如何精确计算出`sizeof(ArtMethod)`
> 1. 该整体替换ArtMethod的方案，在于如果`ArtMethod`的size计算有偏差，会导致：`部分成员没有替换、替换区域超出了边界`
> 1. 应用开发者无法知道具体Andorid设备的系统里`ArtMethod的尺寸`
> 1. 通过`class_linker.cc`源码中`LoadClassMembers()->AllocArtMethodArray()`中可以知道`ArtMethod Array(数组)`的`ArtMethod`是紧密相连的。通过相邻两个`ArtMethod`的`起始地址的差值`就是`ArtMethod的精准大小`
> 1. 类方法分为`Direct方法`和`Virtual方法`，各自有各自的`ArtMethod数组`
>      * direct方法: static方法和所有不可继承的对象方法
>      * virtual方法: 所有可以继承的对象方法

7、借助ArtMethod紧密相连的特性，如何精准计算出ArtMethod的大小?
> 1. 构造一个辅助的类，并具有两个空方法：
>    * f1()、f2()都是`static`方法，都属于`direct ArtMethod Array`
>    * NativeStructsModel中只有`这两个方法`，因此肯定是相邻的
```java
// f1()、f2()都是`static`方法，都属于
public class NativeStructsModel{
  final public static void f1(){}
  final public static void f2(){}
}
```
> 2. 在`JNI层`计算出`f1()和f2()`地址的差值。
```java
  size_t firstMid = (size_t) env->GetStaticMethodId(nativeStructModelClazz, "f1", "()V");
  size_t secondMid = (size_t) env->GetStaticMethodId(nativeStructModelClazz, "f2", "()V");
  // 第二个方法起始地址 - 第一个方法起始地址
  size_t methodSize = secondMid - firstMid;
```
> 3. 该`Size就可以直接作为ArtMethod的尺寸`
```c
//  memcpy(srcMeth, destMeth, sizeof(ArtMethod));

// 替换为:
  memcpy(srcMeth, destMeth, methodSize);
```

##### 唯一注意点

8、利用技巧获取到ArtMethod尺寸的优缺点
> 1. 优势：对于所有Android版本都不需要区分
> 1. 注意点：只要`ArtMethod数组`依旧是`线性结构`，无论`ArtMethod的成员`如何改变，都完美兼容。
> 1. `ArtMethod数组`的`线性结构`会被修改的可能性极低！

#### 访问权限

## 问题汇总

## 参考资料
