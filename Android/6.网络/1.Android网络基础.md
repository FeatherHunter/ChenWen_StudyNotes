转载请注明链接：http://blog.csdn.net/feather_wch/article/details/79643743

# Android网络基础(41题)
版本：2018/8/26-1(23：59)

[TOC]

## 基础(3)

1、网络分层是什么？
>1. 将`数据的发送、转发、打包、拆包`，以及`控制信息的加载和拆出`等工作，分别交由不同的层级去完成。
>2. 最终将`通信和网络互联`的复杂问题变得简单。

2、网络分层(五层从上至下)
|层级|作用|
|---|---|
|1.应用层|拆解数据并进行解读, 有`http\ftp\telnet\smtp\pop3`等协议|
|2.传输层|为两台主机上应用程序提供`端到端`的通信，`TCP(传输控制协议)`和`UDP(用户数据报协议)`|
|3.网络层|该层决定`数据`如何从发送方`路由`到接收方，会根据网络等各种因素决定传输的`最佳路径`|
|4.数据链路层|控制`网络层`和`物理层`之间的通信。作用：确保在不可靠物理线路上进行数据的可靠传输。`网络层数据`会分割为可供`物理层`传输的`帧`，该层会额外附加上`接收方物理地址、纠错和控制信息`，接收方如果检测到差错，发送方会重新发送该帧数据。|
|5.物理层|该层负责`比特流`在节点间的传输。该层的协议与链路有关，也与传输介质有光(光纤、双绞线等)|

3、什么叫做协议？
>1. 为实现一定功能需要双方共同遵守的规则

## TCP(3)

1、TCP的传输过程
>打开连接->写请求数据->读相应数据->关闭连接

2、TCP三次握手
>1. 第一次握手：建立连接后客户端发送`连接请求报文段(SYN =1, Sequence Number(seq) = x)`，并等待服务端确认(`客户端进入SYN_SENT状态`)。
>2. 第二次握手：服务端接收信息并确认后，将`SYN, ACK=(seq)x+1, seq=y`返回给`客户端`，自身进入`SYN_RCVD状态`
>3. 第三次握手：客户端接收到服务端的`SYN+ACK`报文段, 将`ACK=y+1`报文段发送给服务器。发送后`服务端和客户端`进入`ESTABLISHED(连接成功)`状态。

3、TCP四次挥手:
>1. 第一次挥手：客户端向服务端发送一个`FIN报文段`并进入`FIN_WAIT_1状态`-表示客户端没有数据要发送给服务端了。
>2. 第二次挥手：服务端收到后，向客户端发送`ACK报文段`。
>3. 第三次挥手：服务端向客户端发送`FIN报文段`，请求关闭连接，自身进入`LAST_ACK状态`
>4. 第四次挥手: 客户端收到服务端发送的`FIN报文段`，并向服务端发送`ACK报文段`，客户端进入`TIME_WAIT状态`, 服务端收到客户端的`ACK报文段`后就关闭连接。客户端等待`2MSL(最大报文段生存时间)`后没收到回复就关闭连接。

## Http(26)

1、 Http是什么？特点有哪些？
>1. Http是一种`应用层`的`面向对象的协议`
>2. `Http`便捷高效快捷，适用于`分布式超媒体信息系统`。
>3.

2、 \*Http的历史
>1. Http1.1： 1997年版本，进一步完善了Http协议，当前最流行版本。
>2. SPDY: 2009年谷歌为解决`Http1.1效率不高`的问题而自行研发的协议(目的在于通过`压缩、多路复用、优先级`来压缩网页的`加载时间`和`提高安全性`)
>3. Http2: 2015年发布，继承自`SPDY`并最终吸收了`SPDY协议的特性`(谷歌v587)

3、Http的keepalive connections机制的作用
>1. 如果有大量连接，tcp的三次握手和四次挥手会导致性能低下。
>2. Http会在传输完成后仍然保持连接，再次请求数据时，能复用之前空闲下来的连接，提高性能。

4、 Http协议的主要特点
>1. 支持C/S模式
>2. 简单快捷：请求数据只需通过`GET、HEAD、POST`方法，通信速度极快。
>3. 灵活：Http允许传输`任何类型的数据对象`, 用`Content-Type`标记即可。
>4. 短连接：每次连接只传输一个数据。
>5. 无状态: `Http`是无状态协议，指`协议对事务处理没有记忆能力`。`优点：服务端应答速度块`；`缺点：需要先前信息就需要重传之前的数据。`

5、Http Url的格式
>`http://host[:port][abs_path]``
>1. `http`: 表明是http协议
>2. `host`: 合法的Internet主机域名或者IP地址。
>3. `port`: 端口号
>4. `abs_path`: 请求资源的`URL`(Web上任意可用的资源)

6、Http的报文什么特点？
>1. Http报文是面向文本的
>2. 报文中每个字段都是一些ASCII码串，长度不确定

7、HTTP请求报文的组成(4个)
>1. 请求行
>2. 请求报头
>3. 空行
>4. 请求数据

8、HTTP相应报文的组成(4)
>1. 状态行
>2. 相应报头
>3. 空行
>4. 响应正文

9、Http的请求方法有哪些？((请求行的Method字段))
>1. GET: 请求获取`URI`标识的资源
>2. POST: 在`URI`标识的资源后附加新的数据
>3. PUT: 请求服务器存储一个资源(并用`URI`作为其标识)
>4. HEAD: 请求由URI所标识资源的响应消息的报头
>5. DELETE: 请求服务器删除`URI`所标识的资源。
>6. TRACE: 让服务器回送收到的请求信息。多用于测试。
>7. OPTIONS: 查询服务器的性能，或者查询资源相关的选项和需求。

10、Http的通用报头的主要组成
>1. Date： 消息产生的Date
>2. Cache-Control: 用于指定缓存指令

11、Http的请求报头的主要组成
>1. Host： 主机名
>2. User-agent: 请求方的浏览器类型、操作系统等信息, 如`Oppo R9s Build`
>3. Accept: 用于指定客户端接收哪些类型的信息, 如`text/css`
>4. Accept-Encoding: 客户端可以识别的数据编码, 如`gzip, deflate`
>5. Accept-Language: 浏览器所支持的语言类型，如`zh-CN,en-US`
>6. Connection: 如果是`kepp-alive`表示客户端和服务端保持连接

12、实体报头
>1. Content-type: 实体正文的媒体类型，如`text/css`
>2. Content-Lenghh: 正文长度，如`1534`
>3. Content-Encoding: 编码类型，如`gzip`，表示：想要获取到`Content-type：text/css`类型的实体内容，需要通过`gzip解码`
>4. Last-Modified: 资源最后的修改日期，如`Tue,13 Mar 2018 02:59:28 GMT`
>5. Expires: 响应过期的日期和时间，如`Wed,13 Mar 2019 03:02:26 GMT`

13、通过GET/POST发送请求的数据的区别？
>1. `GET`会将请求的数据放置在`URL`上，会导致用户数据泄露。
>2. `POST`将数据放置在`正文`中，安全性更好。
>3. 最好的发送数据的办法是，将信息加密后通过`POST`方法发送

### 常见返回码

14、HTTP返回的常见错误信息
>1. `400~499`: 客户端错误，或者请求无法实现。
>2. `500~599`: 服务器错误，服务器不能实现合法的请求。
>3. 403: 服务器接收到请求但是拒绝提供服务。
>4. 500: 服务器内部错误。

15、204的作用
> 1. 表响应报文中包含若干首部和一个状态行，但是没有实体的主体内容。
> 1. 使用场景：对于一些提交到服务器处理的数据，只需要返回是否成功的情况下，可以考虑用状态码204来作为返回信息，从而省略多余的数据传输。

16、205的作用
> 1. 205则是告知浏览器清除当前页面中的所有html表单元素，也就是表单重置。

### Android中的使用

17、HttpClient和HttpURLConnection的特点和区别
>1. `HttpClient`已经被废弃和移除(Android 6.0)
>2. `Android 2.3以前`适合使用`HttpClient`,`包括2.3及其以后的版本`适合使用`HttpURLConnection`
>3. `HttpURLConnection`具有`压缩和缓存机制`，可以有效减少网络访问的流量。

18、HttpClient的特点
> 1. 相比于HttpUrlConnection更加高效简洁
> 2. 结构过于复杂，维护成本高。
> 3. Android 5.0后被废弃

19、HttpURLConnection的特点
> 1. Android 2.2前：存在调用close()函数会影响连接池，导致连接复用失效的重大BUG
> 2. Android 2.2后：默认开启了gzip压缩，并且提高了Https的性能
> 3. Andorid 4.4后：底层实现已经被OkHttp替换。

### Cookie

20、Cookie是什么？
>1. `Cookie`用于浏览器使用`Http协议`时与服务器保持活动状态(`保活`)
>2. `Cookie`文件保存在本地(`具有不安全性`)
>3. `Cookie`能保存例如`用户账号/密码`等信息
>4. `Cookie`具有时效性：有`临时性Cookie(超时清除，存储在app内存中)`和`持续性Cookie`

21、Cookie机制定义了两种报头
>1. Set-Cookie报头：包含于Web服务端的响应头中(ResponseHeader)
> 2. Cookie报头：包含于Web客户端的请求头中(RequestHead)

22、Cookie在Http中的使用流程
```Sequence
Web Client->Web Server:发送Http Reqeust
Web Server->Web Client:Http Response + Set-Cookie
Web Client->Web Server:Http Reqeust + Cookie
Web Server->Web Client:Http Response
```

### Session

23、Session是什么？特点？
>1. `Session`是用于在`服务端`多个页面中具有`关联性-保持登录状态等`(`Http`是无状态的)
>2. `Session`轻量级，能避免`服务器`为了具有`关联性`，而去查找`数据库`等操作。
>3. `Session`就像是`服务端的一个全局信息`
>4. `Session`保存在`服务器`，具有`安全性`
>5. `Session`依赖于`Cookie`-`本地客户端`需要用Cookie保存`Session ID`
>6. `Session`具有时效性，例如`浏览器`关闭会导致`Session`失效(本地存储SessionID的Cookie丢失导致的)，或者服务端设置了失效时间。

24、Cookie与Session区别
>1. Cookie保存在客户端浏览器，Session保存在服务端(客户端会通过Cookie来保存`SessionID`)
>2. Session适合保存登录信息等安全性较高的信息
>3. Cookie保存其他不重要的信息

### Token
25、Token是什么？特点？
>1. 令牌-用户身份的验证方式
>2. 用户注册或登陆后，服务器会生成Token并存在服务端数据库中，并会把`Token`返回给`客户端`
>3. 客户端请求时都会附带上`Toekn`
>4. 服务端接收到`Token`会与服务端`Toeken`对比，1-值相同，则表示用户处于登录状态(或者验证是否是合法用户) 2-值不相同，则表示登陆过期需要重登。

26、Tooken与Session的区别
>1. `Session`主要是解决`Http无状态`的问题
>2. `Tooken`主要用于`身份认证`，也可以包含一些参数来用保持状态(登录状态等)

## Https(7)
1、Https的数据传输是如何保障安全的？对称算法的纪要
>1. 使用`对称加密算法`
>2. `对称加密算法`是指双方都是使用同一个`密钥S`进行加密解密
>3. `服务器端`和`多个客户端`之间都采用的不同`对称加密算法`
>4. 对于约定使用`哪个对称加密算法`对于约定的过程就需要使用`非对称加密算法`进行加密。

2、非对称加密算法是什么？有哪些特点？
>1. `服务端具有唯一私钥`，`多个客户端`具有`公钥`
>2. `私钥`加密的内容，所有`客户端`都可以用`公钥`进行解密
>3. `公钥`加密的内容，只有`服务端唯一的私钥`解密
>4. `特点是单向安全`---`客户端->服务端`
>5. `公钥`需要服务器发送给`客户端`，这个过程可能会被掉包。

3、公钥被掉包问题
>1. `中间人`可以和`服务端`之间有合法的`公钥和私钥`
>2. `中间人`将`假公钥`发给`客户端`，这样`客户端`发送的内容，`中间人`可以用`假私钥`进行解密并篡改，然后使用`真公钥`发送给`服务端`
>3. `服务端`发送给`中间人`的信息也被会解密，篡改后用`假私钥`加密发送给`客户端`

4、非对称加密算法中公钥如何防止被掉包？
>1. 使用`第三方机构`的`私钥`对`服务端公钥`加密后，再发送给`客户端`(并将`数字证书(第三方机构的公钥)`一并发送给客户端)。
>2. `客户端`用`第三方机构提供的公钥`进行解密
>3. `中间人`用`假私钥`加密的内容，是无法用`第三方机构的公钥解密的`，因此保证了`公钥获取`的安全性
。
>4. `安全隐患`在于`中间人`也可以去申请`合法的数字证书`，对`数字证书`进行掉包。

5、数字证书的作用
>1. 保护`非对称加密算法`的`公钥`的安全问题
>2. 数字证书由第三方机构CA颁发
>3. 数字证书的内容就是明文的`第三方机构公钥`+`数字签名`

6、数字签名的作用
>1. 保证`数字证书`内容的唯一性，不可篡改性。
>2. `数字签名`制作过程：对`数字证书`上的明文内容(`第三方机构公钥`+其他内容)进行`Hash`加密，生成不可逆的hash值H，再对`H`使用`第三方机构私钥`进行加密，最终生成`数字签名`
>3. 保证了`数字签名`无法篡改，`数字证书的明文内容`无法篡改(客户端用同样的方法去生成`数字签名`，与证书上签名进行比对，只要不一样就表示`数据被篡改`)

7、数字证书的要点
>1. `系统和浏览器`维护着一个`第三方机构列表-有其所有数字证书`
>1. `数字证书`直接从`本机上`获取的，因此约定`非对称加密算法的公钥时`，就是使用的该`数字证书`进行安全保障，因此`中间人`没有机会去`掉包数字证书`，除非系统层面被攻破
>1. `Fidder`抓包的原理是`在系统中安装合法的fidder证书`，使用该证书对`我们通讯所用的数字证书掉包`

## 开源库(1)

1、为什么要用使用网络请求开源库？
> 1. 不使用网络请求框架时，网络请求交互很复杂：需要考虑到线程池、缓存等一系列问题。
> 2. 异步请求
> 3. 线程池
> 4. 缓存
>5. 降低开发难度
>6. 缩短开发周期
>7. 使用方便

## 知识储备环节(1)

1、ResetFul Api
>1. 主要是用于多种前端(`Android\ios\web`)请求服务器时(同一种功能)，能使用同一个`api接口`而不是使用很多接口。

# 参考资料
1. [SPDY协议是什么?](http://blog.csdn.net/makenothing/article/details/53698494)
2. [也许，这样理解HTTPS更容易](http://mp.weixin.qq.com/s/yEs0n__bFekzF2m3QEwNfA)
3. [深入浅出Retrofit](https://segmentfault.com/a/1190000005638577)
4. [主流网络请求开源库的对比](https://www.jianshu.com/p/050c6db5af5a)
