转载请注明链接：http://blog.csdn.net/feather_wch/article/details/79643743

# Android网络基础(71题)
版本：2018/8/28-1(1：59)

---

[TOC]

## 基础(4)

1、网络分层是什么？
>1. 将`数据的发送、转发、打包、拆包`，以及`控制信息的加载和拆出`等工作，分别交由不同的层级去完成。
>2. 最终将`通信和网络互联`的复杂问题变得简单。

2、网络分层(五层从上至下)
|层级|作用|
|---|---|
|1.应用层|定义了如何包装和解析数据。 有`http\ftp\dns\telnet\smtp\pop3`等协议|
|2.传输层|为两台主机上应用程序提供`端到端`的通信，`TCP(传输控制协议)`和`UDP(用户数据报协议)`|
|3.网络层|该层决定`数据`如何从发送方`路由`到接收方，会根据网络等各种因素决定传输的`最佳路径`。具有`IP协议`|
|4.数据链路层|控制`网络层`和`物理层`之间的通信。作用：确保在不可靠物理线路上进行数据的可靠传输。`网络层数据`会分割为可供`物理层`传输的`帧`，该层会额外附加上`接收方物理地址、纠错和控制信息`，接收方如果检测到差错，发送方会重新发送该帧数据。该层有`ARP协议`|
|5.物理层|该层负责`比特流`在节点间的传输。该层的协议与链路有关，也与传输介质有关(光纤、双绞线等)|

3、什么叫做协议？
>1. 为实现一定功能需要双方共同遵守的规则

4、ARP和RARP协议的作用。
> 1. ARP协议是将IP地址解析为Mac地址，即硬件地址，这样就找到了唯一设备。
![ARP和RARP](https://gss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=21fe01aa5b82b2b7a7ca31c2019de7d7/622762d0f703918f2056a464533d269758eec49d.jpg)

## TCP(7)

1、TCP的传输过程
>打开连接->写请求数据->读相应数据->关闭连接

2、Socket和TCP/UDP的关系？
> 1. Socket是一组封装的编程调用接口。
> 1. 通过Socket能通过TCP、UDP进行网络通信。

### 三次握手

3、TCP三次握手
>1. 第一次握手：建立连接后客户端发送`连接请求报文段(SYN =1, Sequence Number(seq) = x)`，并等待服务端确认(`客户端进入SYN_SENT状态`)。
>2. 第二次握手：服务端接收信息并确认后，将`SYN, ACK=(seq)x+1, seq=y`返回给`客户端`，自身进入`SYN_RCVD状态`
>3. 第三次握手：客户端接收到服务端的`SYN+ACK`报文段, 将`ACK=y+1`报文段发送给服务器。发送后`服务端和客户端`进入`ESTABLISHED(连接成功)`状态。
```sequence
客户端->服务端:SYN=1, seq=x
服务端->客户端:SYN=1, ACK=x+1, seq=y
客户端->服务端:ACK=y+1, seq=z
```
> x是生成的随机数

4、SYN是什么？
> synchronize，请求同步

5、ACK是什么？
> acknowledgement，确认同步

6、建立连接为什么需要三次握手？(或者为什么需要滴三次握手？)
> 1. 前两次握手是必要的：客户端请求连接，服务端响应连接
> 1. 第三次握手的意义在于：客户端在发送第一次握手的连接请求后(第一次握手)，因为某些原因断开了连接。服务端之后接收到该请求，然后发送响应小心(第二次握手)，并且开始等待客户端发送数据。但其实连接已经断开了，通过第三次握手，确保连接的可靠性，减少资源浪费。

### 四次挥手

7、TCP四次挥手:
>1. 第一次挥手：客户端向服务端发送一个`FIN报文段`并进入`FIN_WAIT_1状态`-表示客户端没有数据要发送给服务端了。
>2. 第二次挥手：服务端收到后，向客户端发送`ACK报文段`。
>3. 第三次挥手：服务端向客户端发送`FIN报文段`，请求关闭连接，自身进入`LAST_ACK状态`
>4. 第四次挥手: 客户端收到服务端发送的`FIN报文段`，并向服务端发送`ACK报文段`，客户端进入`TIME_WAIT状态`, 服务端收到客户端的`ACK报文段`后就关闭连接。客户端等待`2MSL(最大报文段生存时间)`后没收到回复就关闭连接。

### 滑动窗口协议

### 流量控制和拥塞控制

## Http(35)

1、 Http是什么？特点有哪些？
>1. Http是一种`应用层`的`面向对象的协议`
>2. `Http`便捷高效快捷，适用于`分布式超媒体信息系统`。
>3.

2、 \*Http的历史
>1. Http1.1： 1997年版本，进一步完善了Http协议，当前最流行版本。
>2. SPDY: 2009年谷歌为解决`Http1.1效率不高`的问题而自行研发的协议(目的在于通过`压缩、多路复用、优先级`来压缩网页的`加载时间`和`提高安全性`)
>3. Http2: 2015年发布，继承自`SPDY`并最终吸收了`SPDY协议的特性`(谷歌v587)

3、 Http协议的主要特点
>1. 支持C/S模式
>2. 简单快捷：请求数据只需通过`GET、HEAD、POST`方法，通信速度极快。
>3. 灵活：Http允许传输`任何类型的数据对象`, 用`Content-Type`标记即可。
>4. 短连接：每次连接只传输一个数据。
>5. 无状态: `Http`是无状态协议，指`协议对事务处理没有记忆能力`。`优点：服务端应答速度块`；`缺点：需要先前信息就需要重传之前的数据。`

4、Http为什么要无状态？
> 1. 能提高服务端的响应速度
> 1. 缺点是两次请求间没有联系。

5、Http Url的格式
>`http://host[:port][abs_path]``
>1. `http`: 表明是http协议
>2. `host`: 合法的Internet主机域名或者IP地址。
>3. `port`: 端口号
>4. `abs_path`: 请求资源的`URL`(Web上任意可用的资源)

6、Http的请求方法有哪些？((请求行的Method字段))
>1. GET: 请求获取`URI`标识的资源
>2. POST: 在`URI`标识的资源后附加新的数据
>3. PUT: 请求服务器存储一个资源(并用`URI`作为其标识)
>4. HEAD: 请求由URI所标识资源的响应消息的报头
>5. DELETE: 请求服务器删除`URI`所标识的资源。
>6. TRACE: 让服务器回送收到的请求信息。多用于测试。
>7. OPTIONS: 查询服务器的性能，或者查询资源相关的选项和需求。

7、通过GET/POST发送请求的数据的区别？
>1. `GET`会将请求的数据放置在`URL`上，会导致用户数据泄露。
>2. `POST`将数据放置在`正文`中，安全性更好。
>3. 最好的发送数据的办法是，将信息加密后通过`POST`方法发送

### 请求报文和响应报文

8、Http的报文什么特点？
>1. Http报文是面向文本的
>2. 报文中每个字段都是一些ASCII码串，长度不确定

9、HTTP请求报文的组成(4个)
|名称|组成|
|---|---|
|请求行|请求方法(Get/Post)、请求路径Url、协议版本等|
|请求报头(Headers)|header, 包括各种字段|
|空行||
|请求体|发送的数据|

10、HTTP相应报文的组成(4个)
|名称|组成|
|---|---|
|状态行|状态码(200等)、协议版本等|
|响应报头(Headers)|header, 包括各种字段|
|空行||
|响应正文|响应的正文数据|

#### 通用报头

11、Http的通用报头的主要组成
>1. Date： 消息产生的Date
>2. Cache-Control: 用于指定缓存指令

#### 请求报头

12、Http的请求报头的主要组成
>1. Host： 主机名
>2. User-agent: 请求方的浏览器类型、操作系统等信息, 如`Oppo R9s Build`
>3. Accept: 用于指定客户端接收哪些类型的信息, 如`text/css`
>4. Accept-Encoding: 客户端可以识别的数据编码, 如`gzip, deflate`
>5. Accept-Language: 浏览器所支持的语言类型，如`zh-CN,en-US`
>6. Connection: 如果是`keep-alive`表示客户端和服务端保持连接

13、如果本次请求希望服务端返回的数据使用gzip压缩该怎么办？
> 请求报头：Header的`Accept-Encoding`字段指明使用`gzip`

#### 实体报头

14、实体报头
>1. Content-type: 实体正文的媒体类型，如`text/css`
>2. Content-Lenghh: 正文长度，如`1534`
>3. Content-Encoding: 编码类型，如`gzip`，表示：想要获取到`Content-type：text/css`类型的实体内容，需要通过`gzip解码`
>4. Last-Modified: 资源最后的修改日期，如`Tue,13 Mar 2018 02:59:28 GMT`
>5. Expires: 响应过期的日期和时间，如`Wed,13 Mar 2019 03:02:26 GMT`

15、如果本次请求的内容想使用gzip压缩该怎么办？
> 实体报头：Header的` Content-Encoding`字段指明使用`gzip`

16、Accept-Encoding和Content-Encoding使用gzip的区别？
> 1. Content-Encoding: 是本次请求或者响应，内容的文本采用了`gzip`压缩。
> 1. Accept-Encoding: 表示这次请求希望服务端返回的数据采用`gzip`压缩。

#### keepalive

17、Http的keepalive connections机制的作用
>1. 如果有大量连接，tcp的三次握手和四次挥手会导致性能低下。
>2. Http会在传输完成后仍然保持连接，再次请求数据时，能复用之前空闲下来的连接，提高性能。

#### 常见返回码

18、HTTP返回的常见错误信息
>1. `400~499`: 客户端错误，或者请求无法实现。
>2. `500~599`: 服务器错误，服务器不能实现合法的请求。
>3. 403: 服务器接收到请求但是拒绝提供服务。
>4. 500: 服务器内部错误。

19、204的作用
> 1. 表响应报文中包含若干首部和一个状态行，但是没有实体的主体内容。
> 1. 使用场景：对于一些提交到服务器处理的数据，只需要返回是否成功的情况下，可以考虑用状态码204来作为返回信息，从而省略多余的数据传输。

20、205的作用
> 1. 205则是告知浏览器清除当前页面中的所有html表单元素，也就是表单重置。

### Http的缓存机制

21、Http的缓存机制是如何实现的？
> 主要是通过Header中的两个字段来实现：
> 1. Cache-control
> 1. ETag

#### Cache-control

22、Cache-control的作用？
> 用于设置缓存策略

23、Cache-control的主要字段
|字段|功能|
|---|---|
|private|只有客户端可以缓存|
|public|客户端和代理服务器都可以缓存|
|max-age|缓存过期的时间。如果缓存没有过期，则直接使用缓存。|
|no-cache|需要让服务端对比数据是否更新过来验证缓存是否有效。就算max-age没有过期，依旧需要发送一次请求向服务端确认数据是否更新。如果数据更新过，返回304；否则返回新数据，与ETag相配合|
|no-store|所有内存都不进行缓存|

#### ETag

24、ETag是什么？
> 1. 用来对比缓存，是服务端资源的标识码。
> 1. 第一次请求资源时，会额外返回一个Header ETag(哈希值，通过资源计算得到)。
> 1. 第二次请求资源时，会通过header `if-None-Match`将该ETag发给服务端。
> 1. 服务端比对`if-None-Match`和资源的Hash值一致，表明没有更新过数据，返回304。
> 1. 服务端比对结果不一致，表明数据需要更新，返回新资源和返回码200.

25、在第二次请求资源时将ETag的数值通过ETag header就可以提交给服务端？
> 错误！
> 需要通过`if-None-match`提交给服务端。

### Android中的使用

26、HttpClient和HttpURLConnection的特点和区别
>1. `HttpClient`已经被废弃和移除(Android 6.0)
>2. `Android 2.3以前`适合使用`HttpClient`,`包括2.3及其以后的版本`适合使用`HttpURLConnection`
>3. `HttpURLConnection`具有`压缩和缓存机制`，可以有效减少网络访问的流量。

26、HttpClient的特点
> 1. 相比于HttpUrlConnection更加高效简洁
> 2. 结构过于复杂，维护成本高。
> 3. Android 5.0后被废弃

27、HttpURLConnection的特点
> 1. Android 2.2前：存在调用close()函数会影响连接池，导致连接复用失效的重大BUG
> 2. Android 2.2后：默认开启了gzip压缩，并且提高了Https的性能
> 3. Andorid 4.4后：底层实现已经被OkHttp替换。

### Cookie

28、Cookie是什么？
>1. `Cookie`用于浏览器使用`Http协议`时与服务器保持活动状态(`保活`)
>2. `Cookie`文件保存在本地(`具有不安全性`)
>3. `Cookie`能保存例如`用户账号/密码`等信息
>4. `Cookie`具有时效性：有`临时性Cookie(超时清除，存储在app内存中)`和`持续性Cookie`

29、Cookie机制定义了两种报头
> 1. Set-Cookie报头：包含于服务端的响应头中(ResponseHeader)
> 2. Cookie报头：包含于客户端的请求报文的请求头中(RequestHead)

30、Cookie在Http中的使用流程
```Sequence
Web Client->Web Server:发送Http Reqeust
Web Server->Web Client:Http Response + Set-Cookie
Web Client->Web Server:Http Reqeust + Cookie
Web Server->Web Client:Http Response
```
> 1. 前两步：是第一次请求数据，并且获取cookie(主要是登陆等功能)
> 1. 后两步：是用该cookie去保持状态，请求其他数据。

#### Android开发中问题场景

31、Anndroid开发中的实际问题
> 1. 场景：加载WebView中的H5页面需要是已经登录状态。需要将Android原生页面登陆后得到的jsessionid写入到WebView的Cookie中。
> 1. 问题描述：Cookie始终没有被带上，导致请求验证失败。
> 1. 解决办法：
```java
CookieManager cookieManager = CookieManager.getInstance();
if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP){
    // >= API21 需要手动开启
    cookieManager.setAcceptThirdPartyCookies(mWebView, true);
}else{
    cookieManager.setAcceptCookie(true);
}
```

### Session

32、Session是什么？特点？
>1. `Session`是用于在`服务端`多个页面中具有`关联性`-例如：保持登录状态等(`Http`是无状态的)
>2. `Session`轻量级，能避免`服务器`为了具有`关联性`，而去查找`数据库`等操作。
>3. `Session`就像是`服务端的一个全局信息`
>4. `Session`保存在`服务器`，具有`安全性`
>5. `Session`依赖于`Cookie`-`本地客户端`需要用Cookie保存`Session ID`
>6. `Session`具有时效性，例如`浏览器`关闭会导致`Session`失效(本地存储SessionID的Cookie丢失导致的)，或者服务端设置了失效时间。

33、Cookie与Session区别
>1. Cookie保存在客户端浏览器，Session保存在服务端(客户端会通过Cookie来保存`SessionID`)
>2. Session适合保存登录信息等安全性较高的信息
>3. Cookie保存其他不重要的信息

### Token
34、Token是什么？特点？
>1. 令牌-用户身份的验证方式
>2. 用户注册或登陆后，服务器会生成Token并存在服务端数据库中，并会把`Token`返回给`客户端`
>3. 客户端请求时都会附带上`Toekn`
>4. 服务端接收到`Token`会与服务端`Toeken`对比，1-值相同，则表示用户处于登录状态(或者验证是否是合法用户) 2-值不相同，则表示登陆过期需要重登。

35、Tooken与Session的区别
>1. `Session`主要是解决`Http无状态`的问题
>2. `Tooken`主要用于`身份认证`，也可以包含一些参数来用保持状态(登录状态等)

## Https(17)

1、Https是什么？
> 1. Https = Http + SSL
> 1. HTTPS是使用TLS/SSL加密的HTTP协议

2、Http和Https有什么区别？
> 1. HTTP（Hypertext Transfer Protocol）超文本传输协议, 采用明文传输信息，具有安全隐患。
> 1. HTTPS(Secure Hypertext Transfer Protocol) 安全超文本传输协议: 使用安全套接层协议(SSL)进行信息交换，更安全。

### SSL

3、SSL是什么？
> 1. Secure Socket Layer，是安全套接字层协议(+传输层协议`TLS`)
> 1. 层级：位于`TCP/IP`协议和应用层协议之间。
> 1. 为数据通讯提供安全支持，是目前使用最广泛的协议。

4、TLS是什么
> 1. Transport Layer Security，传输层安全协议
> 1. 在两个通信应用程序之间提供保密性和数据完整性
> 1. 该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。
> 1. 底层的是TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。

#### SSL证书

5、SSL数字证书(SSL证书)是什么？
> 1. 一种遵守SSL协议的数字证书。
> 1. 因为配置在服务器上，也称为SSL服务器证书。
> 1. 由资深的数字证书颁发机构CA(例如：GlobalSign等机构)，在验证服务器身份后颁发。

##### Android开发中问题场景

6、Google Play上架问题
> 1. 提示：SSL Error Handler
> 1. 原因：SSL过期，导致报错，为了避免安全问题，需要进行有效处理
> 1. 解决办法：找到WebViewClient按照规范处理onReceivedSslError(让用户选择)。
```java
public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {
                final SslErrorHandler mHandler ;
                mHandler= handler;
                AlertDialog.Builder builder = new AlertDialog.Builder(activity);
                builder.setMessage("ssl证书验证失败");
                builder.setPositiveButton("继续", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        mHandler.proceed();
                    }
                });
                builder.setNegativeButton("取消", new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        mHandler.cancel();
                    }
                });
                builder.setOnKeyListener(new DialogInterface.OnKeyListener() {
                    @Override
                    public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
                        if (event.getAction() == KeyEvent.ACTION_UP && keyCode == KeyEvent.KEYCODE_BACK) {
                            mHandler.cancel();
                            dialog.dismiss();
                            return true;
                        }
                        return false;
                    }
                });
                AlertDialog dialog = builder.create();
                dialog.show();
            }
```

#### CA

6、CA是什么？
> 1. 证书授权中心(CA, Ceritificate Authority)
> 1. CA负责签发证书、认证证书、管理证书
> 1. CA会公开对应的公钥，私钥放在服务器上。

7、CSR是什么?
> 1. 证书请求文件（Certificate Signing Request）
> 1. 申请数字证书时，CSP（加密服务提供者）会生成`私钥`和`证书请求文件`.
> 1. 申请者将CSR交给CA后，CA使用CA机构的私钥进行签名，就生成了`证书公钥文件
`。该公钥就是交给用户的公钥。

### 对称加密算法
8、Https的数据传输是如何保障安全的？对称算法的是什么？
>1. Https中数据的传输使用`对称加密算法`
>2. `对称加密算法`是指双方都是使用同一个`密钥S`进行加密解密
>3. `服务器端`和`多个客户端`之间都采用的不同`对称加密算法`
>4. 对于约定使用`哪个对称加密算法`对于约定的过程就需要使用`非对称加密算法`进行加密。

### 非对称加密算法
9、非对称加密算法是什么？有哪些特点？
>1. `服务端具有唯一私钥`，`多个客户端`具有`公钥`
>2. `私钥`加密的内容，所有`客户端`都可以用`公钥`进行解密
>3. `公钥`加密的内容，只有`服务端唯一的私钥`解密
>4. `特点是单向安全`---`客户端->服务端`
>5. `公钥`需要服务器发送给`客户端`，这个过程可能会被调包。

#### 调包
10、公钥被掉包问题
>1. `中间人`可以和`服务端`之间有合法的`公钥和私钥`
>2. `中间人`将`假公钥`发给`客户端`，这样`客户端`发送的内容，`中间人`可以用`假私钥`进行解密并篡改，然后使用`真公钥`发送给`服务端`
>3. `服务端`发送给`中间人`的信息也被会解密，篡改后用`假私钥`加密发送给`客户端`

11、非对称加密算法中公钥如何防止被掉包？
>1. 使用`第三方机构`的`私钥`对`服务端公钥`加密后，再发送给`客户端`(并将`数字证书(第三方机构的公钥)`一并发送给客户端)。
>2. `客户端`用`第三方机构提供的公钥`进行解密
>3. `中间人`用`假私钥`加密的内容，是无法用`第三方机构的公钥解密的`，因此保证了`公钥获取`的安全性
。
>4. `安全隐患`在于`中间人`也可以去申请`合法的数字证书`，对`数字证书`进行掉包。

#### 数字证书
12、数字证书的作用
>1. 保护`非对称加密算法`的`公钥`的安全问题
>2. 数字证书由第三方机构CA颁发
>3. 数字证书的内容就是明文的`服务端公钥`+`数字签名`
>1. 服务端和客户端通信，不再是`内容 + 服务器公钥`，而是`内容 + 数字证书`

13、没有数字签名的数字证书的安全隐患？
> 1. 数字证书可以被调包。
> 1. 本质是假服务器将假数据(假私钥进行加密)发送给客户，并且给他一个假的数字证书(假公钥)。
> 1. 最终客户端拿的还是假的非对称加密算法的公钥。

#### 数字签名
14、数字签名的作用
>1. 保证`数字证书`内容的唯一性，不可篡改性。
>2. `数字签名`制作过程：对`数字证书`上的明文内容(`服务器公钥`+其他内容)进行`Hash`加密，生成不可逆的hash值H，再对`H`使用`第三方机构私钥`进行加密，最终生成`数字签名`
>3. 保证了`数字签名`无法篡改，`数字证书的明文内容`无法篡改(客户端用同样的方法去生成`数字签名`，与证书上签名进行比对，只要不一样就表示`数据被篡改`)

15、数字签名的制作过程

16、数字证书为什么不会被篡改？
> 1. 如果篡改了数字证书上的`服务器公钥`, 会导致用`第三方机构公钥`解密`数字签名`后得到的Hash值，和假公钥产生的Hash值不一致。`被篡改！`
> 1. 如果篡改了数字证书上的`数字签名`，假数字签名是使用`假第三方机构私钥`(拿不到CA的私钥)来生成的，因此用`第三方机构公钥`是无法解密的。`被篡改！`
> 1. 如果两者都篡改，因为`篡改数字签名`就会导致失败，所以也能判断出`被篡改！`

17、第三方机构的公钥为什么不会被篡改？
>1. `系统和浏览器`维护着一个`第三方机构列表-包括它们的公钥`
>1. `第三方机构`直接从`本机上`获取的，因此`中间人`没有机会去`调包第三方机构`，除非系统层面被攻破
>1. `Fidder`抓包的原理是`在系统中安装合法的fidder证书(具有假的第三方机构公钥)`，对`我们通讯所用的数字证书掉包`后，我们会使用`Fidder的第三方机构公钥`进行解密。发现不了`被篡改`！

## Http 2.0(5)

1、Http 2.0协议是什么？
> 1. 相对于Http 1.x具有巨大的提升
> 1. OkHttp支持配置使用Http 2.0协议

2、Http 2.0和Http 1.x的区别
> 1. http2.0是二进制格式；http1.x是文本协议。
> 1. http2.0支持多路复用；http1.x是一个请求一个连接。
> 1. http2.0支持header头部压缩。
> 1. http2.0支持服务端推送。

### 二进制协议

3、Http 2.0的二进制格式
> 1. http2.0是二进制协议
> 1. 以`帧`为基本单位
> 1. 一帧中包含了`数据`和`Stream Identifier`(该帧的标志，标识了该帧属于哪个request)

### 多路复用

4、Http2.0的多路复用
> 1. 多个请求共用一个TCP连接，可以在该TCP上进行并发请求。
> 1. 性能高，消耗少。

5、如何实现多个请求可以在一个TCP连接上并发？
> 1. Http2.0的二进制分帧实现的。
> 1. 每一帧数据都有一个身份标识。
> 1. 多个请求的不同帧可以无序、并发的发送出去。
> 1. 服务端会根据每一帧的身份标识，将其整理到对应的request中。


## 开源库(1)

1、为什么要用使用网络请求开源库？
> 1. 不使用网络请求框架时，网络请求交互很复杂：需要考虑到线程池、缓存等一系列问题。
> 2. 异步请求
> 3. 线程池
> 4. 缓存
>5. 降低开发难度
>6. 缩短开发周期
>7. 使用方便

## 知识储备环节(2)

1、ResetFul Api
>1. 主要是用于多种前端(`Android\ios\web`)请求服务器时(同一种功能)，能使用同一个`api接口`而不是使用很多接口。

2、Chrome inspect工具可以调试Anfroid的WebView

# 参考资料
1. [SPDY协议是什么?](http://blog.csdn.net/makenothing/article/details/53698494)
1. [也许，这样理解HTTPS更容易](http://mp.weixin.qq.com/s/yEs0n__bFekzF2m3QEwNfA)
1. [Http协议面试题小结](https://blog.csdn.net/weixin_38051694/article/details/77777010)
1. [面试时，你被问到过 TCP/IP 协议吗?](https://blog.csdn.net/yulyu/article/details/69062288)
1. [HTTP面试题都在这里](https://www.cnblogs.com/Java3y/p/8444033.html)
1. [深入浅出Retrofit](https://segmentfault.com/a/1190000005638577)
1. [主流网络请求开源库的对比](https://www.jianshu.com/p/050c6db5af5a)
1. [Retrofit的使用、优势与源码分析](https://www.jianshu.com/p/06a35a0f34d2)
