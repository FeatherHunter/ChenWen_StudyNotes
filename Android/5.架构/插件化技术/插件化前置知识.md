转载请注明链接: https://blog.csdn.net/feather_wch/article/details/88368431


# 插件化前置知识

版本：2019-03-11(2:44)

---

[toc]
> 要先掌握插件化所涉及的到的方方面面的基础知识，才能真正理解差简化、热修复的原理。

## Binder机制

1、Binder是什么?
> 1. 用于进程间通信
> 1. Android中各个app、系统服务运行于不同进程中，需要借助Binder进行通信。
> 1. 从Linux内核角度看，Linux存在进程隔离和虚拟地址空间，导致进程间无法共享数据。所以需要借助IPC

2、Binder机制的步骤分析
> 进程A借助Binder机制获取到进程B的服务结果，步骤分析：
> 1. 进程B创建Binder对象
> 1. 进程A接收到进程B的Binder对象
> 1. 进程A利用进程B传来的对象发起请求
> 1. 进程B收到并处理进程A的请求
> 1. 进程A获取到进程B返回的处理结果

3、Binder机制参考资料
> 1. [Android IPC](https://blog.csdn.net/feather_wch/article/details/79190230)
> 1. [Binder机制详解](https://blog.csdn.net/feather_wch/article/details/79415202)
> 1. [Android进程间通信详解](https://blog.csdn.net/feather_wch/article/details/81136290)

## hook

### 代理

1、代理模式也成为委托模式，分为两种
> 1. 静态代理
> 1. 动态代理

2、代理模式有什么用?
> 1. 限制了对象的访问，对内部对象进行保护
> 1. 如果内部对象的字段发生变化，对于代理类来说，不影响对外的接口，只需要内部进行适配。

#### 静态代理

3、AIDL中的代理模式?代理模式的应用场景？
> 1. AIDL中采用`静态代理`
> 1. 进程A获取到服务进程B的Binder对象时, 生成一个代理对象，通过该代理对象直接进行`加减等操作`、
> 1. `给进程A一种假象，获取到了进程B的对象，并进行了操作`。本质是`内部进行了传入数据给B进行处理，最终从B中获取到结果`等一系列操作。

#### 动态代理

4、动态代理是什么？如何实现？
> 1. 动态代理就是`编译阶段`不知道具体代理类，在`运行阶段`才指定了`代理类`
> 1. 通过`Java的InvocationHandler类`
```java
// 1、自定义类实现 InvocationHandler接口
// 2、重写`invoke()方法`
// 3、调用 Proxy.newProxyInstance(classloader, claz[], invocationHandler); 返回一个代理类
```

### hook

1、什么是Hook?
> 1. Hook-钩子，是指对一些方法进行拦截，这些方法调用时，能够执行`自定义的代码逻辑`
> 1. 是一种`面向切面编程的思想AOP`

2、Android中进行Hook的思路
> 1. 找到需要Hook的方法，所属的`系统类`
> 1. 利用代理模式来`代理系统类`，拦截并执行`自定义逻辑`
> 1. 利用反射，将`系统类`替换为`代理类`

### 反射

1、Java中的反射机制是什么?
> 1. 在运行状态中，对于任意一个类，都能知道`类的所有属性和方法`
> 1. 并且能够调用其方法或者获取其属性

### Hook实例

2、利用Hook实现剪切板服务的复制和粘贴，粘贴的内容都是我们指定的内容。

#### 剪切板服务的使用

1、剪切板服务是如何使用的？
> 点击按钮后将自定义内容，放入到系统剪切板中。
```java
        mEditText = findViewById(R.id.clipboard_edittext);
        findViewById(R.id.clipboard_btn).setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {

                // 1、获取到剪切板服务
                ClipboardManager clipboardManager = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
                // 2、创建String类型的clipData
                ClipData clipData = ClipData.newPlainText("label", mEditText.getText().toString());
                // 3、将ClipData内容放到系统剪切板里面
                clipboardManager.setPrimaryClip(clipData);
            }
        });
```

#### 剪切板的原理

2、获得系统剪切板服务的源码流程
> 本质是从`ServiceManager`的`sCache(HashMap)`获取到`剪切板服务的Binder对象(实现了IBinder接口)`
```java
    // Activity.java-getSystemService(Context.CLIPBOARD_SERVICE)
    public Object getSystemService(String name) {
        // 1、WindowManager
        if (WINDOW_SERVICE.equals(name)) {
            return mWindowManager;
        }
        // 2、搜索服务Manager
        else if (SEARCH_SERVICE.equals(name)) {
            ensureSearchManager();
            return mSearchManager;
        }
        // 3、进一步寻找“剪切板服务”
        return super.getSystemService(name);
    }

    // ContextThemeWrapper.java
    public Object getSystemService(String name) {
        // 1、布局加载服务
        if (LAYOUT_INFLATER_SERVICE.equals(name)) {
            mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(this);
            return mInflater;
        }
        // 2、进一步寻找“剪切板服务”
        return getBaseContext().getSystemService(name);
    }

    // ContextImpl.java
    public Object getSystemService(String name) {
        return SystemServiceRegistry.getSystemService(this, name);
    }

    // SystemServiceRegistry.java - 从HashMap中取出
    private static final HashMap<String, ServiceFetcher<?>> SYSTEM_SERVICE_FETCHERS = new HashMap<String, ServiceFetcher<?>>();
    public static Object getSystemService(ContextImpl ctx, String name) {
        ServiceFetcher<?> fetcher = SYSTEM_SERVICE_FETCHERS.get(name);
        return fetcher != null ? fetcher.getService(ctx) : null;
    }

    /**==========================================
     * 问题：HashMap(SYSTEM_SERVICE_FETCHERS)是如何初始化的？ClipBoard服务是何时放入该HashMap中的?
     *   1. 调用registerService方法对剪切板服务进行注册
     * // SystemServiceRegistry.java
     *==============================================*/
    registerService(Context.CLIPBOARD_SERVICE, ClipboardManager.class,new CachedServiceFetcher<ClipboardManager>() {
        @Override
        public ClipboardManager createService(ContextImpl ctx) throws ServiceNotFoundException {
            // 1、创建剪切板管理器
            return new ClipboardManager(ctx.getOuterContext(), ctx.mMainThread.getHandler());
        }});
    // SystemServiceRegistry.java-将剪切板服务放入到SYSTEM_SERVICE_FETCHERS中
    private static <T> void registerService(String serviceName, Class<T> serviceClass, ServiceFetcher<T> serviceFetcher) {
        SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);
        SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);
    }

    // ClipboardManager.java - 最终通过ServiceManager获取到目标服务
    private final IClipboard mService;
    public ClipboardManager(Context context, Handler handler) throws ServiceNotFoundException {
        // xxx
        // 1、从ServiceManager内部的缓存的HashMap中找，有就返回该IClipboard的Binder对象，要么创建新的返回
        mService = IClipboard.Stub.asInterface(ServiceManager.getServiceOrThrow(Context.CLIPBOARD_SERVICE));
    }

    // ServiceManager.java
    public static IBinder getServiceOrThrow(String name) throws ServiceNotFoundException {
        final IBinder binder = getService(name);
        if (binder != null) {
            return binder;
        } else{
            throw new ServiceNotFoundException(name);
        }
    }
    // ServiceManager.java
    private static HashMap<String, IBinder> sCache = new HashMap<String, IBinder>();
    public static IBinder getService(String name) {
        // 1、返回HashMap-sCache中剪切服务对应的IBinder
        IBinder service = sCache.get(name);
        if (service != null) {
            return service;
        }
        return null;
    }

    // ServiceManager.java - 得到 ClipBoard的Binder對象的代理對象
    public static android.content.IClipboard asInterface(android.os.IBinder obj) {
        if ((obj == null)) {
            return null;
        }
        android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); // Hook点
        if (((iin != null) && (iin instanceof android.content.IClipboard))) {
            return ((android.content.IClipboard) iin);
        }
        return new android.content.IClipboard.Stub.Proxy(obj);
    }
```

#### Hook剪切板服务

1、Hook剪切板服务的流程和实现代码
> 1. 获取到剪切板服务(ClipboardManager)的代理Binder对象
> 1. 将其存入到HashMap中。
> 1. 该Binder对象的剪切板操作的方法逻辑按照我们的需求进行修改。
```java
    /**====================
     * 1、Hook剪切板服务
     *======================*/
    public static void hookClipboard() throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, NoSuchFieldException {
        // 1. 获取系统的ServiceManager
        Class<?> serviceManagerClass = Class.forName("android.os.ServiceManager");
        // 2. 获得ServiceManager的getService方法
        Method getServiceMethod = serviceManagerClass.getMethod("getService", String.class);
        // 3. 通过该方法获取到原系统ClipBoard服务
        IBinder binder = (IBinder) getServiceMethod.invoke(null, Context.CLIPBOARD_SERVICE);
        /**============================================
         * 4. 动态代理，创建自己的代理对象。
         *    1) 将为Clipboard的IBinder对象提供代理，该代理类MyClipboardProxy会实现IBinder的接口
         *    2) 调用queryLocalInterface()方法时，获取到我们剪切板的代理Binder对象
         *    3) 该方法就是生成一个新类，该类实现了IBinder的接口。
         *===============================================*/
        IBinder myBinder = (IBinder) Proxy.newProxyInstance(serviceManagerClass.getClassLoader(), new Class[]{IBinder.class}, new MyClipboardProxy(binder));
        // 5. 拿到ServiceManager中的缓存IBinder数组
        Field field = serviceManagerClass.getDeclaredField("sCache");
        field.setAccessible(true);
        Map<String, IBinder> map = (Map<String, IBinder>) field.get(null);
        // 6. 将我们自定义的ClipboardManager放入Map中
        map.put(Context.CLIPBOARD_SERVICE, myBinder);
    }

    public static class MyClipboardProxy implements InvocationHandler{

        private final IBinder mSystemBinder;

        public MyClipboardProxy(IBinder iBinder){
            mSystemBinder = iBinder;
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            // 1、拦截原系统类的查询本地是否有“剪切服务代理类”的方法
            if("queryLocalInterface".equals(method.getName())){
                // 2. 拿到系统的Stub
                Class<?> mStubClass = Class.forName("android.content.IClipboard$Stub");
                // 3. 拿到系统的Clipboard本地类
                Class<?> mIClipboard = Class.forName("android.content.IClipboard");
                /**=================================================================
                 * 4. 将其代理为我的Clipboard。该类实现了IClipboard所有剪切板操作的接口。获取剪切板的代理Binder对象
                 *=================================================================*/
                return Proxy.newProxyInstance(mIClipboard.getClassLoader(), new Class[]{mIClipboard}, new MyClipboard(mSystemBinder, mStubClass));
            }
            // 5. 其余方法走原系统的执行
            return method.invoke(mSystemBinder, args);
        }
    }

    public static class MyClipboard implements InvocationHandler{

        private Object mBase;

        public MyClipboard(IBinder systemBinder, Class stub){
            // 拿到asInteface方法，因为源码中执行了这一句，我们也要执行这一句
            try {
                Method asInterface = stub.getDeclaredMethod("asInterface", IBinder.class);
                mBase = asInterface.invoke(null, systemBinder);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            if("setPrimaryClip".equals(method.getName())){
                if(args.length > 0){
                    if(args[0] instanceof ClipData){
                        ClipData clipData = (ClipData) args[0];
                        if(clipData.getItemCount() > 0){
                            // 1、获取到原文本, 附加上修改的内容
                            String srcText = clipData.getItemAt(0).getText().toString();
                            if(!TextUtils.isEmpty(srcText)){
                                // 2、将参数替换为新的ClipData，继续执行原逻辑的方法
                                args[0] = ClipData.newPlainText("label", srcText + "---转自猎羽，请注明链接!");
                            }
                        }
                    }
                }
            }
            // 3、当前和其他方法还是交给系统原逻辑处理
            return method.invoke(mBase, args);
        }
    }
```
> 调用
```java
        try {
            hookClipboard();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        }
```

##### Proxy.newProxyInstance

##### 反射调用

## ClassLoader和dex加载过程

1、Android中具有两个主要的ClassLoader
> 1. PathClassLoader
> 1. DexClassLoader
> 1. 这两者都继承自`BaseDexClassLoader`

### PathClassLoader

2、PathClassLoader的作用
> 1. Android系统通过`PathClassLoader`加载`系统类`和`主Dex中的类`
> 1. 使用继承自`BaseDexClassLoader`的`findClass()进行加载`

3、DexClassLoader的作用
> 1. `加载其他dex文件中的类`
> 1. 使用继承自`BaseDexClassLoader`的`findClass()进行加载`

## 四大组件

1、Activity必须在AndroidManifest中进行注册，如何绕开不注册就抛出异常的问题?

2、插件化如何管理插件中四大组件的生命周期?

3、如何加载插件的apk？

### Instrumentation
1、Instrumentation的作用是: 监控应用与系统相关的交互行为

2、相关的方法:
> 1. mInstrumentation.execStartActivity(): 启动Activity
> 1. mInstrumentation.newActivity(): 使用类加载器创建Activity对象
> 1. mInstrumentation.callActivityOnCreate()/callActivityOnResume()等等生命周期的方法: 生命周期

### LoadedApk

1、LoadedApk的作用
> 1. LoadedApk对象是APK文件在内存中的表示。 Apk文件的相关信息，ApplicationInfo、主线程、包名、Application对象都是局部变量。
> 1. 具有创建Application对象的方法。
> 1. 具有内部类：LoadedApk.ServiceDispatcher
> 1. 具有内部类: LoadedApk.ReceiverDispatcher

2、LoadedApk内部类ServiceDispatcher的作用？
> 1. LoadedApk.java的内部类ServiceDispatcher
> 1. 如何让远程服务端调用客户端的ServiceConnection中的方法？
> 1. 需要借助Binder才能让远程服务端回调自己的方法
> 1. ServiceDispatcher的内部类InnerConnection就起到了Binder的作用

3、LoadedApk内部类ReceiverDispatcher的作用？
> LoadedApk.ReceiverDispatcher.InnerReceiver起到了Binder的作用

4、相关方法
> 1. makeApplication()：创建Application对象，该对象唯一，不会重复创建。

### 如何加载插件apk

1、如何加载插件Apk方案1(Hook思想，DroidPlugin框架实现方法)
> 1-加载插件apk需要一个ClassLoader
> 2-系统的ClassLoader通过LoadedApk对象获得。需要构建LoaderApk，修改ClassLoader对象，通过Hook方法将自我构建的LoadedApk添加到ActivityThread的mPackages(HashMap)中。
```java
    final ArrayMap<String, WeakReference<LoadedApk>> mPackages = new ArrayMap<>();
```
> 3-该方案除了需要Hook LoadedApk，在构造LoadedApk中还用到ApplicationInfo对象，需要进行Hook
> 4-ApplicaitonInfo的解析还涉及到手动解析插件中的AndroidManifest文件，过程复杂。

2、如何加载插件Apk方案2
> 1. 借助系统的ClassLoader
> 1. 将插件Apk的信息告诉ClassLoader，让系统帮我们加载
> 1. 将插件apk的dex文件，插入到DexPathList类中的`dexElements数组`即可

### 如何解决插件中Activity未注册的问题？

1、如何解决插件中Activity未注册的问题？
> 1. Hook startActivity()，借助占坑的方法。去加载傀儡Activity。
> 1. 在AndroidManifest中注册一个傀儡Activity，骗过系统层的校验
> 1. 真正创建Activity时，Hook拦截Activity的创建方法，去创建真正的插件apk中的Activity

2、流程分析
```java
        // 1、创建一个属于插件的ClassLoader，传入插件Apk的路径。父类加载器是宿主的类加载器。
        String cachePath = MainActivity.this.getCacheDir().getAbsolutePath();         // dex优化后路径
        String apkPath = Environment.getExternalStorageDirectory().getAbsolutePath() + "/plugin.apk"; // 插件apk的路径
        DexClassLoader mClassLoader = new DexClassLoader(apkPath, cachePath, cachePath, getClassLoader());
        // 2、将宿主apk和插件apk的dex文件加入到新建的dexElements数组中
        PathClassLoader pathLoader = (PathClassLoader) getApplicationContext().getClassLoader(); // PathClassLoader
        // 3、将数组设置给宿主的DexPathList对象
        // 4、拦截Activity的启动。需要去代理AMS的代理类(Binder机制，只能处理AMS的代理类)
        // 5、系统检查完Activity合法性后，拦截系统创建Activity的方法，将傀儡Activity替换为我们需要的Activity
```

#### 启动流程

2、启动流程
```java
//Instrumentation.java
public ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) {
    int result = ActivityManager.getService() //Binder对象
                .startActivity(whoThread, ... ,options);
    // xxx
}
// ActivityManager.java - AMS的代理类
public static IActivityManager getService() {
    return IActivityManagerSingleton.get();
}
// ActivityManager.java - 单例模式
private static final Singleton<IActivityManager> IActivityManagerSingleton = new Singleton<IActivityManager>() {
                @Override
                protected IActivityManager create() {
                    final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);
                    final IActivityManager am = IActivityManager.Stub.asInterface(b);
                    return am;
                }
};
```

3、Hook AMS的代理类
> 1-Hook AMS的代理类，就是代理`ActivityManager.getService()`的返回值就可以了
> 2-获得AMS的代理类ActivityManager
```java
        // 1、获取ActivityManager类
        Class<?> activityManagerClass = Class.forName("android.app.ActivityManager");

        // 2、取出getService方法
        Method getServiceMethod = activityManagerClass.getDeclaredMethod("getService", null);

        // 3、调用getService，获得Singleton<IActivityManager> IActivityManagerSingleton
        Object activityManagerSingleton = getServiceMethod.invoke(null, null);

        // 4、获得AMS的代理对象
        Class<?> singleton = Class.forName("android.util.Singleton"); // 是一个 android.util.Singleton对象;
        Field mInstanceField = singleton.getDeclaredField("mInstance"); // 取出mInstance字段
        mInstanceField.setAccessible(true);
        Object activityManager = mInstanceField.get(activityManagerSingleton);
```
> 3-Hook IActivityManager的startActivity方法

##### ActivityManager

1、ActivityManager是AMS的代理类

##### 为什么占坑Activity的生命周期能给予真正的Activity?

2、为什么占坑Activity的生命周期能给予真正的Activity?
> 1. AMS与ActivityThread之间对于Activity的生命周期的交互，并没有直接使用Activity对象进行交互
> 1. 而是使用一个token来标识，这个token是binder对象，因此可以方便地跨进程传递。
> 1. Activity里面有一个成员变量mToken代表的就是它，token可以唯一地标识一个Activity对象
> 1. 只替换了要启动Activity的信息，并没有替换token，所以系统并不知道当前运行的已经是真正的Activity


## 代码加载

## 资源的使用和动态加载


## 参考资料
1. [插件化框架学习系列博客](https://blog.csdn.net/yulong0809/article/list/1?)
