转载请注明链接:


# 插件化前置知识

版本：2019-03-09(13:44)

---

@[toc]
> 要先掌握插件化所涉及的到的方方面面的基础知识，才能真正理解差简化、热修复的原理。

## Binder机制

1、Binder是什么?
> 1. 用于进程间通信
> 1. Android中各个app、系统服务运行于不同进程中，需要借助Binder进行通信。
> 1. 从Linux内核角度看，Linux存在进程隔离和虚拟地址空间，导致进程间无法共享数据。所以需要借助IPC

2、Binder机制的步骤分析
> 进程A借助Binder机制获取到进程B的服务结果，步骤分析：
> 1. 进程B创建Binder对象
> 1. 进程A接收到进程B的Binder对象
> 1. 进程A利用进程B传来的对象发起请求
> 1. 进程B收到并处理进程A的请求
> 1. 进程A获取到进程B返回的处理结果

3、Binder机制参考资料
> 1. [Android IPC](https://blog.csdn.net/feather_wch/article/details/79190230)
> 1. [Binder机制详解](https://blog.csdn.net/feather_wch/article/details/79415202)

## hook

### 代理

1、代理模式也成为委托模式，分为两种
> 1. 静态代理
> 1. 动态代理

2、代理模式有什么用?
> 1. 限制了对象的访问，对内部对象进行保护
> 1. 如果内部对象的字段发生变化，对于代理类来说，不影响对外的接口，只需要内部进行适配。

#### 静态代理

3、AIDL中的代理模式?代理模式的应用场景？
> 1. AIDL中采用`静态代理`
> 1. 进程A获取到服务进程B的Binder对象时, 生成一个代理对象，通过该代理对象直接进行`加减等操作`、
> 1. `给进程A一种假象，获取到了进程B的对象，并进行了操作`。本质是`内部进行了传入数据给B进行处理，最终从B中获取到结果`等一系列操作。

#### 动态代理

4、动态代理是什么？如何实现？
> 1. 动态代理就是`编译阶段`不知道具体代理类，在`运行阶段`才指定了`代理类`
> 1. 通过`Java的InvocationHandler类`
```java
// 1、自定义类实现 InvocationHandler接口
// 2、重写`invoke()方法`
// 3、调用 Proxy.newProxyInstance(classloader, claz[], invocationHandler); 返回一个代理类
```

### hook

1、什么是Hook?
> 1. Hook-钩子，是指对一些方法进行拦截，这些方法调用时，能够执行`自定义的代码逻辑`
> 1. 是一种`面向切面编程的思想AOP`

2、Android中进行Hook的思路
> 1. 找到需要Hook的方法，所属的`系统类`
> 1. 利用代理模式来`代理系统类`，拦截并执行`自定义逻辑`
> 1. 利用反射，将`系统类`替换为`代理类`

### 反射

1、Java中的反射机制是什么?
> 1. 在运行状态中，对于任意一个类，都能知道`类的所有属性和方法`
> 1. 并且能够调用其方法或者获取其属性

### Hook实例

2、利用Hook实现剪切板服务的复制和粘贴，粘贴的内容都是我们指定的内容。

#### 剪切板服务的原理

#### 拿到

## ClassLoader和dex加载过程

1、Android中具有两个主要的ClassLoader
> 1. PathClassLoader
> 1. DexClassLoader
> 1. 这两者都继承自`BaseDexClassLoader`

### PathClassLoader

2、PathClassLoader的作用
> 1. Android系统通过`PathClassLoader`加载`系统类`和`主Dex中的类`
> 1. 使用继承自`BaseDexClassLoader`的`findClass()进行加载`

3、DexClassLoader的作用
> 1. `加载其他dex文件中的类`
> 1. 使用继承自`BaseDexClassLoader`的`findClass()进行加载`

###

## 应用启动过程

## 代码加载

## 资源的使用和动态加载


## 参考资料
1. [插件化框架学习系列博客](https://blog.csdn.net/yulong0809/article/list/1?)
