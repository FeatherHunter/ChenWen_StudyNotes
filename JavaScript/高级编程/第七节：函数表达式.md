1、定义函数的方式
> 1.函数声明：
> 1. 函数声明提升：在执行代码之前会先读取函数声明，意味着可以把函数声明放在调用它的语句后面
```
function functionName(arg0,arg1,arg2){
  //函数体
}
//函数声明提升
sayHi();
function sayHi(){
  alert("Hi");
}
```
> 2.使用函数表达式：
> 1. 这种情况下创建的是匿名函数(又叫拉姆达函数)——function后面没有标识符
> 2. 这种函数在使用前必须赋值；
```
var functionname = function(arg0,arg1,arg2){
  //函数体
}
```
```
//这样的代码会导致错误
sayHi();                   //函数还不存在
function sayHi(){
  alert("Hi");
}
```

2、函数提升
> 1.关键：理解函数声明和函数表达式之间的区别；
> 2.使用函数声明；
```
//不要这样做，在ECMAScript中属于无效语法
if(condition){
  function sayHi(){
    alert("Hi");
  }
}else{
  function sayHi(){
    alert("Hello");
  }
}
```
> 3.使用函数表达式：
```
//可以这样做
var sayHi;
if(condition){
  sayHi = function (){
    alert("Hi");
  }
}else{
  sayHi = function (){
    alert("Hello");
  }
}
```

3、递归函数
> 1.递归函数是在一个函数通过名字调用自身的情况下构成的；
```
function factorial(num){
  if(num <= 1){
    return 1;
  }else{
    return num * factorial(num-1);
  }
}

var anotherFactorial = factorial;
factorial = null;
alert(anotherFactorial(4));        //出错，factorial已经不是一个函数
```
> 2.解决方法：arguments.callee是一个指向正在执行的函数的指针；
```
function factorial(num){
  if(num <= 1){
    return 1;
  }else{
    return num * arguments.callee(num-1);
  }
}
```
> 3.在严格模式下，不能通过脚本访问arguments.callee，此时，我们使用命名函数表达式；
```
var factorial = (function f(num){
  if(num <= 1){
    return 1;
  }else{
    return num * f(num-1);
  }
});
```

4、闭包
> 1.定义：指有权访问另一个函数作用域中的变量的函数；

5、创建闭包的方式
> 1.在一个函数内部创建另一个函数；
```
function createComparisonFunction(propertyName){
  return function(objec1,object2){
    var value1 = object1[propertyName];
    var value2 = object2[propertyName];
    if(value1 < value2){
      return -1;
    }else if(value1 > value2){
      return 1;
    }else{
      return 0;
    }
  }
}
```
