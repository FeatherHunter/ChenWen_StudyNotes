1、定义函数的方式
> 1.函数声明：
> 1. 函数声明提升：在执行代码之前会先读取函数声明，意味着可以把函数声明放在调用它的语句后面
```
function functionName(arg0,arg1,arg2){
  //函数体
}
//函数声明提升
sayHi();
function sayHi(){
  alert("Hi");
}
```
> 2.使用函数表达式：
> 1. 这种情况下创建的是匿名函数(又叫拉姆达函数)——function后面没有标识符
> 2. 这种函数在使用前必须赋值；
```
var functionname = function(arg0,arg1,arg2){
  //函数体
}
```
```
//这样的代码会导致错误
sayHi();                   //函数还不存在
function sayHi(){
  alert("Hi");
}
```

2、函数提升
> 1.关键：理解函数声明和函数表达式之间的区别；
> 2.使用函数声明；
```
//不要这样做，在ECMAScript中属于无效语法
if(condition){
  function sayHi(){
    alert("Hi");
  }
}else{
  function sayHi(){
    alert("Hello");
  }
}
```
> 3.使用函数表达式：
```
//可以这样做
var sayHi;
if(condition){
  sayHi = function (){
    alert("Hi");
  }
}else{
  sayHi = function (){
    alert("Hello");
  }
}
```

3、递归函数
> 1.递归函数是在一个函数通过名字调用自身的情况下构成的；
```
function factorial(num){
  if(num <= 1){
    return 1;
  }else{
    return num * factorial(num-1);
  }
}

var anotherFactorial = factorial;
factorial = null;
alert(anotherFactorial(4));        //出错，factorial已经不是一个函数
```
> 2.解决方法：arguments.callee是一个指向正在执行的函数的指针；
```
function factorial(num){
  if(num <= 1){
    return 1;
  }else{
    return num * arguments.callee(num-1);
  }
}
```
> 3.在严格模式下，不能通过脚本访问arguments.callee，此时，我们使用命名函数表达式；
```
var factorial = (function f(num){
  if(num <= 1){
    return 1;
  }else{
    return num * f(num-1);
  }
});
```

4、闭包
> 1.定义：指有权访问另一个函数作用域中的变量的函数；

5、创建闭包的方式
> 1.在一个函数内部创建另一个函数；
```
function createComparisonFunction(propertyName){
  return function(objec1,object2){                //匿名函数
    var value1 = object1[propertyName];           //可以访问外部函数中的变量对象
    var value2 = object2[propertyName];
    if(value1 < value2){
      return -1;
    }else if(value1 > value2){
      return 1;
    }else{
      return 0;
    }
  }
}
```

6、闭包的作用域链
> 1.外部函数的活动对象会被添加到内部函数的作用域链中；
> 2.外部函数执行完毕之后，执行环境会被销毁，其活动对象不会被销毁——内部函数的作用域链中仍存在这个活动对象的引用；
> 3.当内部函数被销毁时，外部函数的活动对象才会被销毁；
```
var compareNames = createComparisonFunction("name");      //创建函数
var result = compareNames({name:"Niky"},{name:"Greg"});   //调用函数
compareNames = null;                                      //解除对匿名函数的引用
```

7、闭包的作用域链引发的副作用
> 1.闭包只能取得内部函数中任何变量的最后一个值；
> 2.实际上，每个函数都返回10；
> 1. 每个函数的作用域链中都保存着createFunctions()函数的活动对象，
> 2. 所以，它们引用的都是同一个变量i;
```
function createFunctions(){
  var result = new Array();
  for(var i = 0; i < 10; i++){
    result[i] = function(){
      return i;
    };
  }
  return result;
}
```

8、解决闭包的副作用(不理解)
> 1.创建匿名函数强制让闭包的行为符合预期；
```
function createFunctions(){
  var result = new Array();
  for(var i = 0; i < 10; i++){
    result[i] = function(num){
      return function(){
        return num;
      }
    }(i);
  }
  return result;
}
```

9、this对象
> 1.this对象是在运行时基于函数的执行环境绑定的；
> 2.在全局函数中，this等于window；
> 3.当函数被作为某个对象的方法调用时，this等于该对象；
> 4.匿名函数的执行环境具有全局性，通常this指向window(编写闭包的方式不同，可能不会那么明显)；
```
var name = "The Window";
var object = {
  name:"My Object",
  getNameFunc:function(){
    return function(){
      return this.name;
    };
  }
};
alert(object.getNameFunc()());   //"The Window"(在非严格模式下)
```

10、内存泄漏
> 1.如果闭包的作用域链中保存着一个HTML元素，意味着该元素无法被销毁。
> 1. 闭包创建了一个循环引用，内部匿名函数保存了对assignHandler()的活动对象的引用，无法减少element的引用数；
> 2. 只要匿名函数存在，element的引用数至少为1，因此，它所占用的内存就永远不会被回收。
```
function assignHandler(){
  var element = document.getElementById("someElement");
  element.onclick = function(){
    alert(element.id);
  };
}
```
> 2.解决方法：
```
function assignHandler(){
  var element = document.getElementById("someElement");
  var id = element.id;                //消除了循环引用
  element.onclick = function(){
    alert(id);
  };
  element = null;          //解除对DOM对象的引用
}
```

11、模仿块级作用域
> 1.JavaScript没有块级作用域的概念；
> 2.在块语句中定义的变量，世家上市在函数中而非语句中创建的。
```
function outputNumbers(count){
  for(var i = 0; i < count; i++){
    alert(i);
  }
  alert(i);       //计数
}
```
